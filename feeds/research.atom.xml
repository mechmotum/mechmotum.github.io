<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Bicycle Laboratorium - research</title><link href="https://mechmotum.github.io/" rel="alternate"/><link href="https://mechmotum.github.io/feeds/research.atom.xml" rel="self"/><id>https://mechmotum.github.io/</id><updated>2024-08-05T00:00:00-07:00</updated><subtitle>E pur si muove</subtitle><entry><title>Biomechanical Optimization with SymPy 1.13 and Opty 1.3</title><link href="https://mechmotum.github.io/blog/sympy-1.13-opty-1.3-release.html" rel="alternate"/><published>2024-08-05T00:00:00-07:00</published><updated>2024-08-05T00:00:00-07:00</updated><author><name>Jason K. Moore</name></author><id>tag:mechmotum.github.io,2024-08-05:/blog/sympy-1.13-opty-1.3-release.html</id><summary type="html">&lt;p class="first last"&gt;SymPy 1.13 and Opty 1.3 can now be used for optimal control solutions
of muscle-driven biomechanical simulation. This blog post shows of a
solution to a muscle driven cycling time trial.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;a class="reference external" href="https://github.com/sympy/sympy/releases/tag/1.13.0"&gt;SymPy 1.13&lt;/a&gt; was released on July 8, 2024. This release includes &lt;a class="reference external" href="https://mechmotum.github.io/blog/czi-sympy-wrapup.html"&gt;all of the
work we did under the CZI Open Source Software for Science Cycle 4 grant&lt;/a&gt;. For example, SymPy now includes new features
for modeling biomechanical multibody systems. The new features include model
construction from joints via a system manager and force actuator classes
including a musculo-tendon model. At the close of the grant period, we
demonstrated how these features can be used in the solution of biomechanical
trajectory optimization and parameter estimation optimal control problems, but
only from development branches of the various intertwined software packages.
Today, we released &lt;a class="reference external" href="https://github.com/csu-hmc/opty/releases/tag/v1.3.0"&gt;Opty 1.3&lt;/a&gt; which can now be used alongside SymPy 1.13 to solve
biomechanical optimal control problems. Opty can now handle symbolic equations
of motion that have many millions of mathematical operations and tens of
thousands of constraints and optimization variables. To help grow adoption,
we've built out a new example gallery that demonstrates how Opty can be used to
solve a variety of problems:&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;a class="reference external image-reference" href="https://opty.readthedocs.io/stable/examples/index.html"&gt;
&lt;img alt="" src="https://objects-us-east-1.dream.io/mechmotum/opty-1.3-examples.png" /&gt;
&lt;/a&gt;
&lt;p class="caption"&gt;Opty 1.3's new example gallery.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;One example in the gallery, the &amp;quot;&lt;a class="reference external" href="https://opty.readthedocs.io/stable/examples/plot_one_legged_time_trial.html"&gt;One-Legged Cycling Time Trial&lt;/a&gt;&amp;quot;,
shows how to find an optimal control solution of a musculo-tendon driven model
that makes use of SymPy 1.13's new biomechanics features. We developed this
example for an activity in TU Delft's 2024 Sports Engineering course to show
the students how models can be used to study how muscles play a role in optimal
performance. The example solves a minimum time cycling race using a model of a
single leg and simplified muscles that drive the leg motion to propel the
bicycle. The example in the gallery is set up with a short race distance but if
you bump the distance up to 80 meters the cyclist starts approaching terminal
velocity. Opty can find an optimal solution for the 17,000 variables in this
problem in about 10 minutes on an AMD Ryzen 5 2600X 12 core machine.&lt;/p&gt;
&lt;p&gt;This produces a reasonably realistic overall motion which can be seen in the
cadence, resulting speed, and the power to accelerate and overcome rolling and
air resistance:&lt;/p&gt;
&lt;img alt="" class="align-center" src="https://objects-us-east-1.dream.io/mechmotum/one-legged-80m-power.png" /&gt;
&lt;p&gt;There is no limit on the fatigue of the muscles so the optimizer finds a
bang-bang style coordination of the muscle excitations to power the leg and
push the muscles to their maximum force production:&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="https://objects-us-east-1.dream.io/mechmotum/one-legged-80m-muscle.png" /&gt;
&lt;p class="caption"&gt;The four muscle forces, muscle lengths, and muscle excitations versus time
during the 80 meter time trial with the minimum race time shown at the top.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This solution results in this overall pedaling motion:&lt;/p&gt;
&lt;center&gt;
  &lt;video controls&gt;
    &lt;source src="https://objects-us-east-1.dream.io/mechmotum/one-legged-80m.mp4" type="video/mp4"&gt;
  &lt;/video&gt;
&lt;/center&gt;&lt;p&gt;Our next step is to incorporate muscles in our 3D nonlinear bicycle-rider
models to enable deeper understanding of how bicycles are balanced and
controlled. Opty can quickly find optimal trajectories of the joint torque
driven model, as shown in our &lt;a class="reference external" href="https://doi.org/10.59490/660179a06bf1082286458109"&gt;BRiM paper&lt;/a&gt;:&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="https://objects-us-east-1.dream.io/mechmotum/brim-paper-opty-example.png" /&gt;
&lt;p class="caption"&gt;Torque driven Opty optimal control solution for the non-linear
Carvallo-Whipple bicycle model.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Thanks to Timo, Sam, Peter, and all the SymPy developers for the contributions
that helped pull all this together! We hope that others can make use of these
models and tools for their own work.&lt;/p&gt;
</content><category term="research"/><category term="sympy"/><category term="czi"/><category term="biomechanics"/><category term="multibody dynamics"/><category term="open source software"/><category term="muscles"/><category term="optimal control"/><category term="bicycle"/><category term="code generation"/></entry><entry><title>SymPy CZI Grant Code Generation &amp; Biomechanics Outcomes</title><link href="https://mechmotum.github.io/blog/czi-sympy-wrapup.html" rel="alternate"/><published>2023-10-27T00:00:00-07:00</published><updated>2023-10-27T00:00:00-07:00</updated><author><name>Jason K. Moore</name></author><id>tag:mechmotum.github.io,2023-10-27:/blog/czi-sympy-wrapup.html</id><summary type="html">&lt;p class="first last"&gt;Summary of the work performed under the Chan-Zuckerberg Foundation
Open Source Software for Science Cycle 4 grant awarded to Sympy and
performed by Delft University of Technology. We developed new
biomechanics capabilities in SymPy and improved code generation
performance for large mathematical expressions.&lt;/p&gt;
</summary><content type="html">&lt;table border="1" class="borderless docutils align-center" style="width: 60%"&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;img alt="sympy-logo" src="https://docs.sympy.org/latest/_images/sympy-500px.png" style="height: 200px;" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="czi-logo" src="https://objects-us-east-1.dream.io/mechmotum/czi-logo.png" style="height: 200px;" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="contents floatcon local topic" id="contents"&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#introduction" id="toc-entry-1"&gt;Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#general-improvements-to-sympy-mechanics" id="toc-entry-2"&gt;General Improvements to SymPy Mechanics&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#joints-package" id="toc-entry-3"&gt;Joints Package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#symbolic-solutions-to-linear-equations" id="toc-entry-4"&gt;Symbolic Solutions to Linear Equations&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#choice-of-generalized-coordinates-and-speeds" id="toc-entry-5"&gt;1. Choice of Generalized Coordinates and Speeds&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#alternative-symbolic-solvers" id="toc-entry-6"&gt;2. Alternative Symbolic Solvers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#division-free-linear-solves" id="toc-entry-7"&gt;3. Division-free Linear Solves&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#delayed-numerical-solves" id="toc-entry-8"&gt;4. Delayed Numerical Solves&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#inertia-loads-actuators" id="toc-entry-9"&gt;Inertia, Loads, Actuators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-class" id="toc-entry-10"&gt;System Class&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#introducing-sympy-biomechanics" id="toc-entry-11"&gt;Introducing SymPy Biomechanics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#code-generation-improvements" id="toc-entry-12"&gt;Code Generation Improvements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#modeling-and-optimal-control-uses" id="toc-entry-13"&gt;Modeling and Optimal Control Uses&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#optimal-skateboard-ollie" id="toc-entry-14"&gt;Optimal Skateboard Ollie&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#brim" id="toc-entry-15"&gt;BRiM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#optimal-bicycle-rider-trajectories" id="toc-entry-16"&gt;Optimal Bicycle-Rider Trajectories&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#conclusion" id="toc-entry-17"&gt;Conclusion&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#lessons-learned" id="toc-entry-18"&gt;Lessons Learned&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#future-plans" id="toc-entry-19"&gt;Future Plans&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#work-summary" id="toc-entry-20"&gt;Work Summary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#references" id="toc-entry-21"&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-1"&gt;Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We were awarded a &lt;a class="reference external" href="https://doi.org/10.6084/m9.figshare.16590053.v1"&gt;two year grant&lt;/a&gt; from CZI to improve &lt;a class="reference external" href="https://www.sympy.org"&gt;SymPy&lt;/a&gt;. There were
three work packages led by each of the three co-principal investigators:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Improve SymPy's Documentation (Aaron Meuer, Quantsight)&lt;/li&gt;
&lt;li&gt;Improve SymPy's Performance (Oscar Benjamin, University of Bristol)&lt;/li&gt;
&lt;li&gt;Improve SymPy's Code Generation for Biomechanical Modeling (Jason K. Moore,
Delft University of Technology)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We were in charge of the last work package and hired Dr. Sam Brockie to work on
the project as a postdoctoral researcher. Jan Heinen and Timo Stienstra worked
on the project through their TU Delft MSc degrees under the supervision of Sam
and Jason.&lt;/p&gt;
&lt;p&gt;Our overarching goal is to use SymPy to generate symbolic dynamical models of
biomechanical systems, i.e. multibody systems actuated by muscles. This
involves formulating the Newton-Euler equations of motion, possibly with
additional kinematic constraints, and the differential equations that describe
the relationship between neurological excitation and generated muscles forces.&lt;/p&gt;
&lt;p&gt;We selected a complex human-machine system as a benchmark problem to motivate
our work: the bicycle and its rider. The nonlinear and linear equations of
motion of a riderless bicycle have traditionally been a very challenging system
to derive correctly in full symbolic form (see &lt;a class="citation-reference" href="#basumandal2007" id="citation-reference-1"&gt;[BasuMandal2007]&lt;/a&gt; and
&lt;a class="citation-reference" href="#meijaard2007" id="citation-reference-2"&gt;[Meijaard2007]&lt;/a&gt; for background). Including a model of a human rider with
muscle-driven joints increases the model's complexity even further. This model
is made up of millions of arithmetic and transcendental operations, making it a
challenging system to differentiate and evaluate efficiently. We want SymPy to
be able to handle models of this complexity with ease. To test SymPy's ability
to correctly derive, differentiate, and evaluate the bicycle-rider's governing
equations, we choose to formulate and solve a &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Trajectory_optimization"&gt;trajectory optimization&lt;/a&gt;
problem via &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Collocation_method"&gt;direct collocation&lt;/a&gt;. We knew that this bicycle-rider optimal
control problem would test SymPy's limits, forcing us to make significant
improvements to SymPy's code generation features. To do this, we worked on
numerous areas in SymPy and downstream packages to reach this goal.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="general-improvements-to-sympy-mechanics"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-2"&gt;General Improvements to SymPy Mechanics&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="joints-package"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-3"&gt;Joints Package&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Timo Stienstra began working on this project through a 2022 Google Summer of
Code internship where he improved the SymPy Mechanics &lt;a class="reference external" href="https://docs.sympy.org/latest/modules/physics/mechanics/joints.html"&gt;joints modules&lt;/a&gt; with
documentation improvements, by reworking the fundamental definition of a joint,
and adding new cylindrical, planar, and spherical joints. These were key early
updates to enable the joints package's use in constructing a bicycle-rider
model. See the details of Timo's work in his &lt;a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2022-Report-Timo-Stienstra-:-Enhancing-the-Joints-Framework"&gt;GSoC Report&lt;/a&gt;. This project led
Timo to do a TU Delft Biomechanical Design MSc project on bicycle-rider
modeling using SymPy.&lt;/p&gt;
&lt;table border="1" class="borderless docutils align-center" style="width: 100%"&gt;
&lt;caption&gt;Figure 1: Old and new joint types with new explanatory figures
can be found in the SymPy documentation.&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;img alt="joint1" src="https://objects-us-east-1.dream.io/mechmotum/PinJoint.png" style="height: 180px;" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="joint2" src="https://objects-us-east-1.dream.io/mechmotum/PrismaticJoint.png" style="height: 180px;" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;img alt="joint3" src="https://objects-us-east-1.dream.io/mechmotum/CylindricalJoint.png" style="height: 180px;" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="joint4" src="https://objects-us-east-1.dream.io/mechmotum/PlanarJoint.png" style="height: 180px;" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;img alt="joint5" src="https://objects-us-east-1.dream.io/mechmotum/SphericalJoint.png" style="height: 180px;" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="joint6" src="https://objects-us-east-1.dream.io/mechmotum/WeldJoint.png" style="height: 180px;" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="symbolic-solutions-to-linear-equations"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-4"&gt;Symbolic Solutions to Linear Equations&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Kane's Method relies on solving three sets of linear equations:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;putting the kinematical differential equations in explicit form
&lt;span class="math"&gt;\(\dot{\mathbf{q}} = \mathbf{M}_k^{-1}\left(\mathbf{u} +
\mathbf{f}_k\right)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;putting the dynamical differential equations in explicit form
&lt;span class="math"&gt;\(\dot{\mathbf{u}} = \mathbf{M}_d^{-1}\mathbf{f}_d\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;solving the dependent generalized speeds in terms of the independent
generalized speeds
&lt;span class="math"&gt;\(\mathbf{u}_r = \mathbf{A}_r^{-1}(\mathbf{A}_s\mathbf{u}_s + \mathbf{f}_{rs})\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If these equations are symbolic, it is mostly impossible to determine if an
entry is zero when pivoting in &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Gaussian_elimination"&gt;Gaussian elimination&lt;/a&gt; making the solutions
susceptible to divide-by-zero operations for ranges of numerical values for the
variables involved.&lt;/p&gt;
&lt;p&gt;There are four ways, it seems, to deal with this:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;select the generalized coordinates, generalized speeds, and constants such
that divide-by-zero cannot occur for the numerical values of interest&lt;/li&gt;
&lt;li&gt;select symbolic Gaussian elimination algorithms that do not put the
solutions in a form that has divide-by-zero for the numerical values of
interest&lt;/li&gt;
&lt;li&gt;use a zero-division free linear solve algorithm&lt;/li&gt;
&lt;li&gt;defer the linear solves to numerical algorithms&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="section" id="choice-of-generalized-coordinates-and-speeds"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-5"&gt;1. Choice of Generalized Coordinates and Speeds&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The choice of generalized coordinates and generalized speeds changes which
entries in the linear coefficient matrix can be zero for specific values of the
coordinates and speeds. It may be possible to avoid divide-by-zero with careful
selection of the variables when defining the kinematics of the specific
problem. But this will require unique solutions for every model.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="alternative-symbolic-solvers"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-6"&gt;2. Alternative Symbolic Solvers&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;In 2014, we switched to using &lt;tt class="docutils literal"&gt;LUsolve()&lt;/tt&gt; for all of the linear solves in
SymPy Mechanics in &lt;a class="reference external" href="https://github.com/sympy/sympy/pull/7581"&gt;PR 7581&lt;/a&gt;, which resulted in an unnoticed regression of
divide-by-zero issues for complex problems. This change broke the crucial
&lt;a class="reference external" href="https://github.com/sympy/sympy/blob/master/sympy/physics/mechanics/tests/test_kane3.py"&gt;test_kane3.py&lt;/a&gt; as well as the corresponding &lt;a class="reference external" href="https://docs.sympy.org/latest/modules/physics/mechanics/examples/bicycle_example.html"&gt;documentation page&lt;/a&gt;
that solved the linear Carvallo-Whipple bicycle model to a machine precision
match against published benchmarks. This bug has hounded us for 9 years (see
&lt;a class="reference external" href="https://github.com/pydy/pydy/pull/122"&gt;https://github.com/pydy/pydy/pull/122&lt;/a&gt; and
&lt;a class="reference external" href="https://github.com/sympy/sympy/issues/9641"&gt;https://github.com/sympy/sympy/issues/9641&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Timo discovered the fundamental divide-by-zero issue after &lt;a class="reference external" href="https://github.com/sympy/sympy/issues/24780"&gt;much sleuthing and
discussion&lt;/a&gt;. He then introduced a new linear solver that uses &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Cramer%27s_rule"&gt;Cramer's
rule&lt;/a&gt;, which can eliminate divide-by-zero operations in many cases. We then
added support to &lt;tt class="docutils literal"&gt;KanesMethod()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;Linearizer()&lt;/tt&gt; for using linear
solvers other than &lt;tt class="docutils literal"&gt;LUSolve()&lt;/tt&gt; including the new Cramer's rule-based solver
as an option. With this we closed the &lt;a class="reference external" href="https://github.com/sympy/sympy/issues/9641"&gt;9 year old bug&lt;/a&gt; and allowed our base
bicycle model to build both in non-linear and linear forms. The new Cramer
solve method for matrices was introduced in
&lt;a class="reference external" href="https://github.com/sympy/sympy/pull/25179"&gt;https://github.com/sympy/sympy/pull/25179&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="division-free-linear-solves"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-7"&gt;3. Division-free Linear Solves&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;There are division-free algorithms that can be used in solving linear systems,
but the complexity of the resulting equations grows considerably, for example
see &lt;a class="citation-reference" href="#bird2011" id="citation-reference-3"&gt;[Bird2011]&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="delayed-numerical-solves"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#toc-entry-8"&gt;4. Delayed Numerical Solves&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;It would be helpful if we could delay linear solves to the numerical
evaluation, so that pivot points can managed by &lt;a class="reference external" href="https://www.netlib.org/lapack/"&gt;LAPACK&lt;/a&gt;'s solvers. To do so, we
would need to be able to use the results of a linear solve like any other
symbol without symbolically evaluating the linear solve operation. The
following SymPy code almost works as desired:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;MatrixSymbol&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Inverse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lambdify&lt;/span&gt;

&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatrixSymbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatrixSymbol&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Inverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;eval_result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lambdify&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The above works but the inverse and matrix multiplication are evaluated
symbolically when called, as can be seen in the generated function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eval_result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;...&lt;/span&gt;
&lt;span class="go"&gt;Source code:&lt;/span&gt;

&lt;span class="go"&gt;def _lambdifygenerated(A, b):&lt;/span&gt;
&lt;span class="go"&gt;    return A[0, 0]*b[1, 0]/(A[0, 0]*A[1, 1] - A[0, 1]*A[1, 0]) - A[0, 1]*b[1, 0]/(A[0, 0]*A[1, 1] - A[0, 1]*A[1, 0]) - A[1, 0]*b[0, 0]/(A[0, 0]*A[1, 1] - A[0, 1]*A[1, 0]) + A[1, 1]*b[0, 0]/(A[0, 0]*A[1, 1] - A[0, 1]*A[1, 0])&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Instead, we'd like &lt;tt class="docutils literal"&gt;lambdify()&lt;/tt&gt; to generate code that looks more like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;eval_result&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
   &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;numpy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;linalg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;solve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which allows NumPy (or actually LAPACK) to use the appropriate algorithm given
the numerical values used for A and b. The expression &lt;tt class="docutils literal"&gt;Inverse(A) &amp;#64; b&lt;/tt&gt; would
need to remain unevaluated for code generation to properly handle it. In SymPy,
there is a &lt;tt class="docutils literal"&gt;MatrixSolve()&lt;/tt&gt; code generation node that acts as an unevaluated
linear equation solver and works as desired with &lt;tt class="docutils literal"&gt;lambdify()&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy.codegen.matrix_nodes&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;MatrixSolve&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MatrixSolve&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;eval_x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lambdify&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;eval_x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="gp"&gt;...&lt;/span&gt;
&lt;span class="go"&gt;Source code:&lt;/span&gt;

&lt;span class="go"&gt;def _lambdifygenerated(A, b):&lt;/span&gt;
&lt;span class="go"&gt;    return solve(A, b)&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But &lt;tt class="docutils literal"&gt;MatrixSolve()&lt;/tt&gt; does not support indexing the solution:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="go"&gt;---------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="go"&gt;NotImplementedError                       Traceback (most recent call last)&lt;/span&gt;
&lt;span class="go"&gt;Cell In[8], line 1&lt;/span&gt;
&lt;span class="go"&gt;----&amp;gt; 1 result = x[0, 0] + x[1, 0]&lt;/span&gt;

&lt;span class="go"&gt;File ~/miniconda/lib/python3.9/site-packages/sympy/matrices/expressions/matexpr.py:300, in MatrixExpr.__getitem__(self, key)&lt;/span&gt;
&lt;span class="go"&gt;    298 i, j = _sympify(i), _sympify(j)&lt;/span&gt;
&lt;span class="go"&gt;    299 if self.valid_index(i, j) != False:&lt;/span&gt;
&lt;span class="go"&gt;--&amp;gt; 300     return self._entry(i, j)&lt;/span&gt;
&lt;span class="go"&gt;    301 else:&lt;/span&gt;
&lt;span class="go"&gt;    302     raise IndexError(&amp;quot;Invalid indices (%s, %s)&amp;quot; % (i, j))&lt;/span&gt;

&lt;span class="go"&gt;File ~/miniconda/lib/python3.9/site-packages/sympy/matrices/expressions/matexpr.py:243, in MatrixExpr._entry(self, i, j, **kwargs)&lt;/span&gt;
&lt;span class="go"&gt;    242 def _entry(self, i, j, **kwargs):&lt;/span&gt;
&lt;span class="go"&gt;--&amp;gt; 243     raise NotImplementedError(&lt;/span&gt;
&lt;span class="go"&gt;    244         &amp;quot;Indexing not implemented for %s&amp;quot; % self.__class__.__name__)&lt;/span&gt;

&lt;span class="go"&gt;NotImplementedError: Indexing not implemented for MatrixSolve&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Timo has an open pull request that uses &lt;tt class="docutils literal"&gt;BlockMatrix()&lt;/tt&gt; with
&lt;tt class="docutils literal"&gt;MatrixSolve()&lt;/tt&gt; for the solution of dependent speeds in &lt;tt class="docutils literal"&gt;KanesMethod&lt;/tt&gt;, that
can at least give this delayed solve with &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;lambdify(modules='NumPy')&lt;/span&gt;&lt;/tt&gt;, see
&lt;a class="reference external" href="https://github.com/sympy/sympy/pull/24916"&gt;https://github.com/sympy/sympy/pull/24916&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="inertia-loads-actuators"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-9"&gt;Inertia, Loads, Actuators&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We introduced three new helper classes to extend the functionality of inertia
and loads beyond that of simply dyadics and vectors: &lt;tt class="docutils literal"&gt;Inertia()&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;Force()&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;Torque()&lt;/tt&gt;. The inertia object lets you associate a dyadic
with a point, to completely define inertia for a rigid body, particle, or
collection of them. Force and Torque are named tuples that associate a vector
and point and a vector and a frame, respectively.&lt;/p&gt;
&lt;p&gt;We have introduced an &lt;a class="reference external" href="https://docs.sympy.org/latest/modules/physics/mechanics/api/actuator.html"&gt;actuator&lt;/a&gt; module that has classes that describe the
equal and opposite pair of forces or torques and force actuators can operate
along a pathway, generating resultant forces on points that lie along the
pathway. We included a linear spring and damper as example actuators. The
pathways are located in the new &lt;a class="reference external" href="https://docs.sympy.org/latest/modules/physics/mechanics/api/pathway.html"&gt;pathway&lt;/a&gt; module.&lt;/p&gt;
&lt;p&gt;These new objects provide core building blocks for developing musculotendon
actuators and managing a full multibody system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="system-class"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-10"&gt;System Class&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Timo developed a new &lt;a class="reference external" href="https://docs.sympy.org/latest/modules/physics/mechanics/api/system.html#sympy.physics.mechanics._system.System"&gt;System()&lt;/a&gt; class that manages all the information about a
multibody system (coordinates, joints, bodies, constraints, etc.) and can
generate the equations of motion from the high level description of the system
without having to manually write the mathematical equations. This approach
generally reduces the amount of code needed to generate the equations for
complex systems. See the &lt;a class="reference external" href="https://docs.sympy.org/latest/modules/physics/mechanics/examples/four_bar_linkage_example.html"&gt;Four-bar Linkage&lt;/a&gt; example to get an idea of how it
works.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="introducing-sympy-biomechanics"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-11"&gt;Introducing SymPy Biomechanics&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We have developed a substantial new sub-package, &lt;a class="reference external" href="https://docs.sympy.org/latest/modules/physics/biomechanics/index.html"&gt;sympy.physics.biomechanics&lt;/a&gt;,
that enables including musculotendon force actuators in multibody dynamics
models created with &lt;tt class="docutils literal"&gt;sympy.physics.mechanics&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;biomechanics&lt;/tt&gt; contains
these primary modules:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;curve.py&lt;/tt&gt;: contains classes that represent mathematical functional
relationships between the time-varying muscle-tendon length, velocity, and
force&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;activation.py&lt;/tt&gt;: contains classes that manage the excitation to activation
dynamics&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;musculotendon.py&lt;/tt&gt;: contains classes that represent complete musculotendon
models with one reference implementation from &lt;a class="citation-reference" href="#degroote2016" id="citation-reference-4"&gt;[DeGroote2016]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A full explanation of this package and the modules can be found in the new
&lt;a class="reference external" href="https://docs.sympy.org/latest/tutorials/physics/biomechanics/biomechanics.html"&gt;Introduction to Biomechanical Modeling&lt;/a&gt;
tutorial. We demonstrate the package on a non-trivial biomechanical system in
the new &lt;a class="reference external" href="https://docs.sympy.org/latest/tutorials/physics/biomechanics/biomechanical-model-example.html"&gt;Biomechanical Model Example&lt;/a&gt;
tutorial.&lt;/p&gt;
&lt;table border="1" class="borderless docutils align-center" style="width: 100%"&gt;
&lt;caption&gt;Figure 2: On the left, the muscle(red)-driven arm (black C and
D) pushing and pulling a lever taken from the new tutorial. On the right,
are simulation results from the model with a commanded muscle excitation.&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;img alt="biomechanics-steerer" src="https://objects-us-east-1.dream.io/mechmotum/biomechanics-steerer.png" style="width: 100%;" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="biomechanics-steerer-results" src="https://docs.sympy.org/latest/_images/biomechanical-model-example-38.png" style="width: 100%;" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="code-generation-improvements"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-12"&gt;Code Generation Improvements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The function &lt;a class="reference external" href="https://docs.sympy.org/latest/modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify"&gt;lambdify()&lt;/a&gt; is the primary interface for converting SymPy
expressions into NumPy-powered Python functions for numerical evaluation.
&lt;tt class="docutils literal"&gt;lambdify()&lt;/tt&gt; relies on SymPy's code generation to generate the appropriate
Python code. &lt;tt class="docutils literal"&gt;lambdify()&lt;/tt&gt; has not been able to handle large mechanics models
in the past. We proposed adding common sub-expression elimination (CSE) support
to help with that.  Support for the &lt;a class="reference external" href="https://docs.sympy.org/latest/modules/simplify/simplify.html#sympy.simplify.cse_main.cse"&gt;cse()&lt;/a&gt; function was added to
&lt;tt class="docutils literal"&gt;lambdify()&lt;/tt&gt; just before we started the CZI work in
&lt;a class="reference external" href="https://github.com/sympy/sympy/pull/21546"&gt;https://github.com/sympy/sympy/pull/21546&lt;/a&gt;. Here is an example that demonstrates
some of the speed improvements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;count_ops&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lambdify&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy.physics.mechanics&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;find_dynamicsymbols&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dynamicsymbols&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy.physics.mechanics.models&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;n_link_pendulum_on_cart&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Generating the equations of motion with &lt;tt class="docutils literal"&gt;KanesMethod&lt;/tt&gt; will be faster for some
models in the next release of SymPy due to &lt;a class="reference external" href="https://github.com/sympy/sympy/pull/24792"&gt;Pull Request 24792&lt;/a&gt;. This shows the speed in SymPy
1.11.1:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [1]: %time kane = n_link_pendulum_on_cart(n=14)
CPU times: user 7.45 s, sys: 3.69 ms, total: 7.46 s
Wall time: 7.47 s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and the same in the tip of the master branch (1.13.dev0):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [1]: %time kane = n_link_pendulum_on_cart(n=14)
CPU times: user 4.85 s, sys: 3.81 ms, total: 4.85 s
Wall time: 4.85 s
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;large_expr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kane&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mass_matrix_full&lt;/span&gt; &lt;span class="o"&gt;@&lt;/span&gt; &lt;span class="n"&gt;kane&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;forcing_full&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;find_dynamicsymbols&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;large_expr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;large_expr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;free_symbols&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dynamicsymbols&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;x_vals&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p_vals&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These expressions have almost 300 thousand operations:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [1]: count_ops(large_expr)
Out[1]: 282836
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In SymPy 1.12, lambdifying large expressions will take at least half the time
as prior versions because there is wasted time printing the full expression to
the docstring. Sam sped up lambdify's code generation by disabling the
docstring generation for large expressions in &lt;a class="reference external" href="https://github.com/sympy/sympy/pull/24754"&gt;Pull Request 24754&lt;/a&gt;. Note that lambdifying
expressions is also faster with &lt;tt class="docutils literal"&gt;cse=True&lt;/tt&gt;. Here is the timing in SymPy
1.11.1:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [1]: %time f_without_cse = lambdify((x, p), large_expr)
CPU times: user 29.4 s, sys: 91.3 ms, total: 29.5 s
Wall time: 29.5 s

In [2]: %time f_with_cse = lambdify((x, p), large_expr, cse=True)
CPU times: user 14.5 s, sys: 15.8 ms, total: 14.5 s
Wall time: 14.5 s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and then the same in SymPy 1.12:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [1]: %time f_without_cse = lambdify((x, p), large_expr)
CPU times: user 17.9 s, sys: 68.4 ms, total: 18 s
Wall time: 18 s

In [2]: %time f_with_cse = lambdify((x, p), large_expr, cse=True)
CPU times: user 2.77 s, sys: 7.93 ms, total: 2.77 s
Wall time: 2.77 s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using &lt;tt class="docutils literal"&gt;cse=True&lt;/tt&gt; with &lt;tt class="docutils literal"&gt;lambdify()&lt;/tt&gt;, results in significantly faster
numerical evaluation:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;In [2]: %timeit f_without_cse(x_vals, p_vals)
40.7 ms ± 824 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [3]: %timeit f_with_cse(x_vals, p_vals)
264 µs ± 7.37 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For this example, the CSE version is &lt;strong&gt;154X faster&lt;/strong&gt; at execution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="modeling-and-optimal-control-uses"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-13"&gt;Modeling and Optimal Control Uses&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As explained in the introduction, our goal is to make SymPy capable of deriving
computationally efficient neuromuscular driven multibody models. One use case
for these models is solving &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Optimal_control"&gt;optimal control&lt;/a&gt; problems, which benefit greatly
from exact derivatives and the fastest numerical evaluation of the equations of
motion and its higher-order partial derivatives. In particular, forming a
&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Nonlinear_programming"&gt;nonlinear programming&lt;/a&gt; problem using direct collocation transcription from
very large symbolic equations of motion was already known to push SymPy's past
its limits.  In the past, we have developed two software packages that
transcribe and solve optimal control problems based on SymPy expressions: &lt;a class="reference external" href="https://github.com/csu-hmc/opty"&gt;opty&lt;/a&gt;
and &lt;a class="reference external" href="https://github.com/brocksam/pycollo"&gt;pycollo&lt;/a&gt;. We use both programs below to solve two challenging optimal
control problems and detail the improvements we made to the packages.&lt;/p&gt;
&lt;div class="section" id="optimal-skateboard-ollie"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-14"&gt;Optimal Skateboard Ollie&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As a first demonstration that SymPy can be used to solve research-grade optimal
control problems, TU Delft MSc student Jan Heinen developed a model of a
skateboarder performing an ollie, the fundamental jumping trick in the sport.
Jan used SymPy to formulate the equations of motion of this biomechanical
human-machine system and used pycollo to solve the multi-phase trajectory
optimization and parameter identification optimal control problem. Jan
succeeded and produced an MSc thesis and a preprint that is currently under
review at the journal Sports Engineering:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;TU Delft MSc thesis: &lt;a class="reference external" href="http://resolver.tudelft.nl/uuid:61f4e969-8bd1-4687-9942-b70024b216dc"&gt;Optimal Skateboard Geometry for Maximizing Ollie Height&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;engrXiv preprint: &lt;a class="reference external" href="https://doi.org/10.31224/3171"&gt;Maximizing Ollie Height by Optimizing Control Strategy and
Skateboard Geometry Using Direct Collocation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This video shows the simulations of the problem solutions:&lt;/p&gt;
&lt;center&gt;
&lt;iframe width="560" height="315"
src="https://www.youtube.com/embed/jw5DmNnvD7c" title="YouTube video player"
frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;&lt;p&gt;Following his MSc project, Jan contributed Sphinx documentation and examples to
the pycollo project with the following pull requests:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/80"&gt;https://github.com/brocksam/pycollo/pull/80&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/82"&gt;https://github.com/brocksam/pycollo/pull/82&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/84"&gt;https://github.com/brocksam/pycollo/pull/84&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/85"&gt;https://github.com/brocksam/pycollo/pull/85&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/87"&gt;https://github.com/brocksam/pycollo/pull/87&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/88"&gt;https://github.com/brocksam/pycollo/pull/88&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="brim"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-15"&gt;BRiM&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;All of our prior bicycle-rider human-machine system models were one-off
derivations that were repurposed for each new model variation. These had
varying accessibility for other users. Timo came up with the idea to develop a
software package that allows you to build bicycle-rider models from modular
elements, yet still retain a minimal coordinate derivation of the equations of
motion. His MSc thesis, &amp;quot;&lt;a class="reference external" href="http://resolver.tudelft.nl/uuid:a2b132e9-8d38-4553-8587-0c9e3341b202"&gt;BRiM: A Modular Bicycle-Rider Modeling Framework&lt;/a&gt;&amp;quot;,
details the design, implementation, and use of BRiM. We also wrote a paper,
&amp;quot;&lt;a class="reference external" href="https://doi.org/10.59490/6504c5a765e8118fc7b106c3"&gt;BRiM: A Modular Bicycle-Rider Modeling Framework&lt;/a&gt;&amp;quot;, for the Bicycle and
Motorcycle Dynamics 2023 conference that gives a more concise overview of the
package as well as demonstrating easily swapping models for comparable optimal
control results.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="" src="https://objects-us-east-1.dream.io/mechmotum/brim-lane-change.gif" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;Figure 3: Lane change simulation created with BRiM showing with and without
a rider.&lt;/p&gt;
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;BRiM source code: &lt;a class="reference external" href="https://github.com/TJStienstra/brim/"&gt;https://github.com/TJStienstra/brim/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BRiM documentation: &lt;a class="reference external" href="https://tjstienstra.github.io/brim/"&gt;https://tjstienstra.github.io/brim/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BRiM BMD 2023 paper: &lt;a class="reference external" href="https://doi.org/10.59490/6504c5a765e8118fc7b106c3"&gt;https://doi.org/10.59490/6504c5a765e8118fc7b106c3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BRiM BMD 2023 paper source code: &lt;a class="reference external" href="https://github.com/TJStienstra/brim-bmd-2023-paper"&gt;https://github.com/TJStienstra/brim-bmd-2023-paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="optimal-bicycle-rider-trajectories"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-16"&gt;Optimal Bicycle-Rider Trajectories&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With all of the above work, we were able to solve an optimal control problem of
the muscle-driven bicycle and rider. This is the problem we posed:&lt;/p&gt;
&lt;blockquote&gt;
Given a multibody model of the Carvallo-Whipple bicycle model extended with
a rider that has muscle actuated movable arms and given a desired path on
the ground, can we find muscle activations that cause the bicycle-rider to
follow the path as closely as possible while minimizing the effort from the
representative biceps and triceps?&lt;/blockquote&gt;
&lt;p&gt;The objective of this optimal control problem takes the form:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
J = (1 - w)\int_{t_0}^{t_f} \left[x_s(t) - x_d(t)\right]^2 dt +
w\int_{t_0}^{t_f} e(t)^2 dt
\end{equation*}
&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(x_s\)&lt;/span&gt; are a subset of the model's state trajectories and
&lt;span class="math"&gt;\(x_d\)&lt;/span&gt; are some desired trajectories and &lt;span class="math"&gt;\(e\)&lt;/span&gt; are the muscle
excitation inputs. &lt;span class="math"&gt;\(w\)&lt;/span&gt; is a weighting factor for the two terms. This is a
typical minimal effort tracking formulation.&lt;/p&gt;
&lt;p&gt;The equations of motion of this system have about 2.8 million mathematical
operations. Forming the constraints that represent these equations of motion (a
set of differential algebraic equations in this case) involves computing a very
large sparse Jacobian with 440 thousand non-zero entries. When we first
attempted the differentiation for the Jacobian of the discretized bicycle-rider
model, SymPy bogged down on the Jacobian calculation. We let the computation
run for &lt;strong&gt;over 3 hours&lt;/strong&gt; and killed the execution before the computation
completed. SymPy's differentiation is unusable for interactive work with large
equations of motion such as these. Since we already find the common
sub-expressions of the equations of motion before code generation in opty, Sam
implemented a very efficient forward Jacobian on the expression directed
acyclic graph (DAG) in pull request: &lt;a class="reference external" href="https://github.com/csu-hmc/opty/pull/102"&gt;https://github.com/csu-hmc/opty/pull/102&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This allowed the equations to be differentiated and the differentiation occurs
in less than 45 seconds (at least a &lt;strong&gt;250X&lt;/strong&gt; speed increase), showing the
drastic improvements such an approach can have. Once this fix was applied we
were finally able to solve the tracking trajectory optimization problem with
&lt;a class="reference external" href="https://github.com/csu-hmc/opty"&gt;opty&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This problem has these characteristics:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Number of operations in the equations of motion: 2,775,718&lt;/li&gt;
&lt;li&gt;Number of constraints: 6394&lt;/li&gt;
&lt;li&gt;Number of free variables: 7400&lt;/li&gt;
&lt;li&gt;Number of non-zero entries in the Jacobian of the constraints: 439,438&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and solves with these timings:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Time to differentiate the constraints: 43 seconds&lt;/li&gt;
&lt;li&gt;Total time to code generate, form the Jacobian, and compile the C code: 185
seconds&lt;/li&gt;
&lt;li&gt;Average time to evaluate the constraints: 201 µs&lt;/li&gt;
&lt;li&gt;Average time to evaluate the Jacobian: 1.29 ms&lt;/li&gt;
&lt;li&gt;Number of IPOPT iterations: 267&lt;/li&gt;
&lt;li&gt;Time in IPOPT: 45 seconds&lt;/li&gt;
&lt;/ul&gt;
&lt;table border="1" class="borderless docutils align-center" style="width: 100%"&gt;
&lt;caption&gt;Figure 4: Optimal control simualtion results for a 2 meter
lange change at a nomimal 1 m/s riding speed. The top left shows the desired
(blue) and actual (orange) ground path. The top right graph shows the
generalized coordintes. &lt;span class="math"&gt;\(q_7\)&lt;/span&gt; is the steer angle in degrees, for example. The
bottom left shows the generalized speeds. &lt;span class="math"&gt;\(u_1\)&lt;/span&gt; is the forward speed.
The bottom right graphs shows the muscle excitation inputs for pedaling
torque &lt;span class="math"&gt;\(T_6\)&lt;/span&gt; and the biceps and triceps.&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="50%" /&gt;
&lt;col width="50%" /&gt;
&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;img alt="muscle-bike-rider-01" src="https://objects-us-east-1.dream.io/mechmotum/muscle-bike-rider-01.png" style="width: 100%;" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="muscle-bike-rider-02" src="https://objects-us-east-1.dream.io/mechmotum/muscle-bike-rider-02.png" style="width: 100%;" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;img alt="muscle-bike-rider-03" src="https://objects-us-east-1.dream.io/mechmotum/muscle-bike-rider-03.png" style="width: 100%;" /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="muscle-bike-rider-04" src="https://objects-us-east-1.dream.io/mechmotum/muscle-bike-rider-04.png" style="width: 100%;" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The simulation codes and the draft paper about the results can be found in the
following repository:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/brocksam/muscle-driven-bicycle-paper"&gt;https://github.com/brocksam/muscle-driven-bicycle-paper&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The need to evaluate both a function and its Jacobian is a common use case that
is not just limited to optimal control problems like the one shown above. SymPy
is capable of taking analytical derivatives but it can be prohibitively slow
for large expressions. This limits interactive use and rapid iteration in
equation derivation. If common sub-expressions are extracted from a SymPy
expression, all operations are represented as a directed acyclic graph.  Taking
the derivative of a DAG instead of a tree graph, as SymPy stores expressions,
can provide exponential speedups to differentiation. If the code generation for
the function and its Jacobian uses common sub-expression elimination, then it
makes sense to call &lt;tt class="docutils literal"&gt;cse()&lt;/tt&gt; on the function, then take the partial
derivatives, and the Jacobian will be in a DAG form for easy code generation.
Sam has introduced a major code generation speed up for lambdifying large SymPy
expressions if you also desire the Jacobian based on the work we did in opty.
The details are  in the following pull requests:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/sympy/sympy/pull/24649"&gt;https://github.com/sympy/sympy/pull/24649&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/sympy/sympy/pull/25797"&gt;https://github.com/sympy/sympy/pull/25797&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/sympy/sympy/pull/25801"&gt;https://github.com/sympy/sympy/pull/25801&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-17"&gt;Conclusion&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We completed almost all of the goals set out in the original proposal along
with many more unplanned achievements. SymPy is now more suited for solving
non-trivial biomechanical optimal control problems and improvements to the
performance of lambdify() will help a broad set of use cases. Our experience
also led to many new ideas on how to further improve SymPy for large expression
manipulation, especially how unevaluated expression forms that use DAGs as the
core data structure can drastically speed up SymPy and reduce the computational
resources needed.&lt;/p&gt;
&lt;div class="section" id="lessons-learned"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-18"&gt;Lessons Learned&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;New contributors to large open source projects should start with pull requests
that are small and uncontroversial to build up momentum. Sam started with a
pull request to switch SymPy's 15 year old testing framework to pytest. This
consumed a lot of time and stalled regularly which in return stalled his other
pull requests because he built out the tests with advanced pytest features.&lt;/p&gt;
&lt;p&gt;We had planned for 0.5 FTE over the two year period, but it took about 6 months
to negotiate a subcontract between TU Delft and Quantsight, since it was the
first one of its kind. After that, it took another six months before we
interivewed candidates, hired one, and Sam could start. There was not enough
time in the grant period for the contract and hiring process. It still worked
out, but this is something to plan for in the future.&lt;/p&gt;
&lt;p&gt;We developed a large plan for the additions to SymPy that was tough to separate
into independent smaller pieces. This led Sam and Timo to work on a set of
large interconnected Git branches that would be merged when finished. This
ended up leaving us with very large pull requests to review and made it harder
for other SymPy developers to interact on the draft work. We also merged all of
the new material as private modules (leading underscores in their file names)
so that we could make breaking changes in case a SymPy release occurred before
we finished the whole plan. The development branch approach was not ideal,
SymPy usually has only one development branch, so we should probably avoid that
in the future. Merging private modules is a fine approach and is done in other
places in SymPy, but you have to have a plan to make them public.&lt;/p&gt;
&lt;p&gt;Our proposal had three work packages. After hiring Sam, we realized his prior
experience and ideas for SymPy improvement had overlap with Oscar's plans. By
the time we understood what exactly we would do, we failed to have more
collaborative work between the two related work packages. In the future, it
would be good to have more early brainstorm meetings to initiate close
collaboration.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="future-plans"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-19"&gt;Future Plans&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We plan to finish any of the unmerged pull requests for the SymPy 1.13 release
and the paper on the optimal control of the bicycle-rider system is ongoing
work. In the future, we are very interested in incorporating unevaluated
expressions and the DAG data structures more into the core of SymPy, as these
two ideas can vastly enhance SymPy's performance and the ability to code
generate from SymPy expressions with more control and precision. We hope that
other users will try out and contribute to the new biomechanics package as well
as use SymPy + opty &amp;amp; pycollo for solving optimal control problems of
biomechanical multibody systems.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="work-summary"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-20"&gt;Work Summary&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The following list summarizes the various products we have delivered as part of
the CZI funding (code, papers, documentation):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Pull requests to SymPy:&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/sympy/sympy/pulls?q=is%3Apr+label%3A%22CZI%3A+Codegen%2FBiomech%22"&gt;https://github.com/sympy/sympy/pulls?q=is%3Apr+label%3A%22CZI%3A+Codegen%2FBiomech%22&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/sympy/sympy_benchmarks/pulls?q=is%3Apr+author%3Abrocksam"&gt;https://github.com/sympy/sympy_benchmarks/pulls?q=is%3Apr+author%3Abrocksam&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pull request to opty: &lt;a class="reference external" href="https://github.com/csu-hmc/opty/pull/102"&gt;https://github.com/csu-hmc/opty/pull/102&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pull requests to pycollo:&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/80"&gt;https://github.com/brocksam/pycollo/pull/80&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/82"&gt;https://github.com/brocksam/pycollo/pull/82&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/84"&gt;https://github.com/brocksam/pycollo/pull/84&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/85"&gt;https://github.com/brocksam/pycollo/pull/85&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/87"&gt;https://github.com/brocksam/pycollo/pull/87&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/pycollo/pull/88"&gt;https://github.com/brocksam/pycollo/pull/88&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Ollie Optimization paper and code:&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mechmotum/ollie-optimization"&gt;https://github.com/mechmotum/ollie-optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BRiM software package:&lt;ul&gt;
&lt;li&gt;Source code: &lt;a class="reference external" href="https://github.com/TJStienstra/brim/"&gt;https://github.com/TJStienstra/brim/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Documentation: &lt;a class="reference external" href="https://tjstienstra.github.io/brim/"&gt;https://tjstienstra.github.io/brim/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BMD 2023 paper: &lt;a class="reference external" href="https://doi.org/10.59490/6504c5a765e8118fc7b106c3"&gt;https://doi.org/10.59490/6504c5a765e8118fc7b106c3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BMD 2023 paper source code: &lt;a class="reference external" href="https://github.com/TJStienstra/brim-bmd-2023-paper"&gt;https://github.com/TJStienstra/brim-bmd-2023-paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Bicycle steering optimal control paper:&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/brocksam/muscle-driven-bicycle-paper"&gt;https://github.com/brocksam/muscle-driven-bicycle-paper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-21"&gt;References&lt;/a&gt;&lt;/h2&gt;
&lt;table class="docutils citation" frame="void" id="meijaard2007" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#citation-reference-2"&gt;[Meijaard2007]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;J. P. Meijaard, J. M. Papadopoulos, A. Ruina, and A. L.
Schwab, “Linearized dynamics equations for the balance and steer of a
bicycle: A benchmark and review,” Proceedings of the Royal Society A:
Mathematical, Physical and Engineering Sciences, vol. 463, no. 2084, pp.
1955–1982, Aug. 2007.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="basumandal2007" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#citation-reference-1"&gt;[BasuMandal2007]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;P. Basu-Mandal, A. Chatterjee, and J. M. Papadopoulos,
&amp;quot;Hands-free circular motions of a benchmark bicycle,&amp;quot; Proceedings of the
Royal Society A: Mathematical, Physical and Engineering Sciences, vol. 463,
no. 2084, pp. 1983–2003, Aug. 2007.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="degroote2016" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#citation-reference-4"&gt;[DeGroote2016]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;De Groote, F., Kinney, A. L., Rao, A. V., &amp;amp; Fregly, B. J.,
Evaluation of direct collocation optimal control problem formulations for
solving the muscle redundancy problem, Annals of biomedical engineering,
44(10), (2016) pp. 2922-2936&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="bird2011" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#citation-reference-3"&gt;[Bird2011]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Richard S. Bird, A simple division-free algorithm for computing
determinants, Information Processing Letters, Volume 111, Issues 21–22,
2011, Pages 1072-1074, ISSN 0020-0190,
&lt;a class="reference external" href="https://doi.org/10.1016/j.ipl.2011.08.006"&gt;https://doi.org/10.1016/j.ipl.2011.08.006&lt;/a&gt;.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="research"/><category term="sympy"/><category term="czi"/><category term="biomechanics"/><category term="multibody dynamics"/><category term="open source software"/><category term="muscles"/><category term="optimal control"/><category term="bicycle"/><category term="skateboard"/><category term="code generation"/></entry><entry><title>Balance Assist Bicycle Featured in CAS Project Video</title><link href="https://mechmotum.github.io/blog/cas-final-video.html" rel="alternate"/><published>2023-06-28T00:00:00-07:00</published><updated>2023-06-28T00:00:00-07:00</updated><author><name>Jason K. Moore</name></author><id>tag:mechmotum.github.io,2023-06-28:/blog/cas-final-video.html</id><summary type="html">&lt;p class="first last"&gt;Dr. Leila Alizadehsaravi and Dr. Felix Dauer are featured in the
final CAS project video with the balance assist bicycle.&lt;/p&gt;
</summary><content type="html">&lt;p&gt;The &lt;a class="reference external" href="https://www.citiusaltiussanius.nl/"&gt;Citius-Altius-Sanius&lt;/a&gt; project is beginning to wrap up and recently a video
was produced highlighting the projects. Check out Dr. Leila Alizadehsaravi and
our partner Felix Dauer from Bosch being interviewed below:&lt;/p&gt;
&lt;iframe width="560" height="315"
src="https://www.youtube.com/embed/ewtgBIHhcNk?start=162" title="YouTube
video player" frameborder="0" allow="accelerometer; autoplay;
clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
allowfullscreen&gt;&lt;/iframe&gt;</content><category term="research"/><category term="bicycle"/><category term="engineering"/></entry><entry><title>New Preprint on Ski Jump Safety and skijumpdesign Software Update</title><link href="https://mechmotum.github.io/blog/ski-jump-analysis.html" rel="alternate"/><published>2021-04-01T00:00:00-07:00</published><updated>2021-04-01T00:00:00-07:00</updated><author><name>Jason K. Moore</name></author><id>tag:mechmotum.github.io,2021-04-01:/blog/ski-jump-analysis.html</id><summary type="html">&lt;p&gt;Yesterday, we posted a new preprint to &lt;a class="reference external" href="https://engrxiv.org"&gt;engrXiv&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
J. K. Moore, B. Cloud, M. Hubbard, and C. A. Brown, &amp;quot;Analysis and Ethical
Design of Terrain Park Jumps for Snow Sports,&amp;quot; Preprint, Mar. 2021.
[Online]. Available: &lt;a class="reference external" href="https://doi.org/10.31224/osf.io/sq7u9"&gt;https://doi.org/10.31224/osf.io/sq7u9&lt;/a&gt;.&lt;/blockquote&gt;
&lt;p&gt;The abstract reads:&lt;/p&gt;
&lt;blockquote&gt;
Most American snowsport resorts …&lt;/blockquote&gt;</summary><content type="html">&lt;p&gt;Yesterday, we posted a new preprint to &lt;a class="reference external" href="https://engrxiv.org"&gt;engrXiv&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
J. K. Moore, B. Cloud, M. Hubbard, and C. A. Brown, &amp;quot;Analysis and Ethical
Design of Terrain Park Jumps for Snow Sports,&amp;quot; Preprint, Mar. 2021.
[Online]. Available: &lt;a class="reference external" href="https://doi.org/10.31224/osf.io/sq7u9"&gt;https://doi.org/10.31224/osf.io/sq7u9&lt;/a&gt;.&lt;/blockquote&gt;
&lt;p&gt;The abstract reads:&lt;/p&gt;
&lt;blockquote&gt;
Most American snowsport resorts now have terrain parks and decades-long
epidemiological evidence correlates terrain park use with injuries.
Engineering design of jumps could reduce injuries by limiting equivalent
fall heights (EFHs), which indicate dissipated landing impact energy. No
evidence refutes making terrain park jumps safer in this way. We discuss
case studies illustrating that large EFHs are significant factors in
traumatic injuries on terrain park jumps. Standards and design tools for
builders can make jumps safer. We introduce a tool that can evaluate
existing jumps as well as design jump profiles with safer equivalent EFHs to
reduce injuries.&lt;/blockquote&gt;
&lt;p&gt;In the paper, we attempt to strengthen the arguments for adopting jump design
standards for public use snow sports jumps. We show how bad jumps can be
through two case studies that resulted in two individuals being paralyzed. We
then highlight the large amount of epidemiological studies that continue to
show the high dangers associated with these jumps and point out that the
scientific literature is also polluted with studies that attempt to cloud the
reality of the dangers; favoring ski industry and insurance companies desires.
Lastly, we discuss the latest release of our software, &lt;a class="reference external" href="https://skijumpdesign.readthedocs.io"&gt;skijumpdesign&lt;/a&gt;, which
has new features that let jump builders analyze existing or planned jumps by
equivalent fall height calculations. These features were used to analyse the
two case studies in the paper.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Equivalent fall height plot of the Salvini case study." src="https://objects-us-east-1.dream.io/mechmotum/salvini-v-snoqualmie.png" style="width: 600px;" /&gt;
&lt;p class="caption"&gt;Example equivalent fall height analysis of a dangerous snow sport jump taken
from the paper.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;a class="reference external image-reference" href="http://www.skijumpdesign.info/analysis"&gt;
&lt;img alt="Screenshot of the skijumpdesign app's analysis page." src="https://objects-us-east-1.dream.io/mechmotum/skijumpdesign-1.4.0-analysis-screenshot.png" style="width: 600px;" /&gt;
&lt;/a&gt;
&lt;p class="caption"&gt;Screenshot of the new &amp;quot;analysis&amp;quot; page of the web app. Click the image to go
to the app.&lt;/p&gt;
&lt;/div&gt;
</content><category term="research"/><category term="skiing"/><category term="snowboarding"/><category term="safety"/><category term="sports"/><category term="engineering"/><category term="ethics"/></entry><entry><title>A Web Application for Analyzing Bicycle Dynamics</title><link href="https://mechmotum.github.io/blog/bicycle-dynamics-web-application.html" rel="alternate"/><published>2020-07-03T00:00:00-07:00</published><updated>2020-07-03T00:00:00-07:00</updated><author><name>Lyla Sanders</name></author><id>tag:mechmotum.github.io,2020-07-03:/blog/bicycle-dynamics-web-application.html</id><summary type="html">&lt;p class="first last"&gt;Blog post on creating a web application to serve as a GUI for bicycle
dynamics.&lt;/p&gt;
</summary><content type="html">&lt;div class="figure align-center"&gt;
&lt;a class="reference external image-reference" href="https://bicycle-dynamics.onrender.com"&gt;
&lt;img alt="" src="https://objects-us-east-1.dream.io/mechmotum/bicycle-dynamics-app.png" style="width: 800px;" /&gt;
&lt;/a&gt;
&lt;p class="caption"&gt;Screenshot of the bicycle dynamics web app. Click the image to go to the app
at &lt;a class="reference external" href="https://bicycle-dynamics.onrender.com"&gt;https://bicycle-dynamics.onrender.com&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="background"&gt;
&lt;h2&gt;Background&lt;/h2&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://github.com/moorepants/BicycleParameters"&gt;BicycleParameters&lt;/a&gt; Python program provides a way for users to interact with
the 27 parameters laid out by the Whipple-Carvallo bicycle model. However, its
accessibility is limited to the programming experience of the user, and it can
be unweildy to manually work with.  To make the program more accessible, the
Bicycle Dynamics Web App was created to supply a graphical user interface for
the program as well as to enable a broader range of users to access it via the
web. The web app takes heavy inspiration from &lt;a class="reference external" href="http://ruina.tam.cornell.edu/research/topics/bicycle_mechanics/JBike6_web_folder/index.htm"&gt;JBike6&lt;/a&gt;, but aims to remove the
accessibility barriers inherent to MATLAB.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="building-the-app"&gt;
&lt;h2&gt;Building the App&lt;/h2&gt;
&lt;p&gt;Given that BicycleParameters was to be used as the backend for the website, it
made sense to use another Python based program to build the frontend. &lt;a class="reference external" href="https://dash.plotly.com"&gt;Dash&lt;/a&gt;
from Plotly serves this purpose perfectly, providing us with a full set of html
components in addition to many custom made Javascript elements such as
datatables and value sliders.  Finally, the app is styled with &lt;a class="reference external" href="https://dash-bootstrap-components.opensource.faculty.ai"&gt;Dash Bootstrap
Components&lt;/a&gt;, so that only a very minimal amount of custom CSS had to be
written.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="functionality"&gt;
&lt;h2&gt;Functionality&lt;/h2&gt;
&lt;p&gt;The Bicycle Dynamics Web App provides a graphical interface with 10 different
default parameter sets, a set of editable tables where users may adjust the
parameter values as they see fit, and two plots which are generated behind the
scenes from the datatable values. The geometry plot displays the essential
schematic and centers of mass of the bicycle, while the eigenvalue plot reveals
the self-stability of the bicycle as a function of its speed. Users may toggle
the centers of mass and intertia ellipsoid on the geometry plot, and they may
adjust the speed range for the eigenvalue plot.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The Bicycle Dynamics Web App is currently deployed at
&lt;a class="reference external" href="https://bicycle-dynamics.onrender.com"&gt;https://bicycle-dynamics.onrender.com&lt;/a&gt; and its github repository is located at
&lt;a class="reference external" href="https://github.com/moorepants/BicycleParameters"&gt;https://github.com/moorepants/BicycleParameters&lt;/a&gt;. Feel free to play around with
the app and provide suggestions or feedback!&lt;/p&gt;
&lt;/div&gt;
</content><category term="research"/><category term="bicycle"/><category term="web application"/></entry><entry><title>Updated Implementation of a PID Controller for Controlling The Speed of an Instrumented Ebike</title><link href="https://mechmotum.github.io/blog/ebike-controller-implementation-updated.html" rel="alternate"/><published>2019-12-30T15:00:00-08:00</published><updated>2019-12-30T15:00:00-08:00</updated><author><name>Trevor Metz</name></author><id>tag:mechmotum.github.io,2019-12-30:/blog/ebike-controller-implementation-updated.html</id><summary type="html">&lt;p class="first last"&gt;Updated blog post on the implementation of a PID controller on an
instrumented ebike&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;em&gt;This is an updated version of a previous blog post on the implementation of a
PID controller on an instrumented ebike which can be&lt;/em&gt; &lt;a class="reference external" href="https://mechmotum.github.io/blog/ebike-controller-implementation.html"&gt;found here&lt;/a&gt;.
&lt;em&gt;Updates include sections 5.4-5.5 discussing the added dead man's switch and
throttle relay and minor fixes throughout.&lt;/em&gt;&lt;/p&gt;
&lt;div class="contents floatcon local topic" id="table-of-contents"&gt;
&lt;p class="topic-title"&gt;&lt;a class="reference internal" href="#top"&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#introduction" id="toc-entry-1"&gt;1.0 Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-operation-functionality" id="toc-entry-2"&gt;2.0 System Operation &amp;amp; Functionality&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-architecture" id="toc-entry-3"&gt;3.0 System Architecture&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#control-architecture" id="toc-entry-4"&gt;3.1 Control Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#physical-architecture" id="toc-entry-5"&gt;3.2 Physical Architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#software" id="toc-entry-6"&gt;4.0 Software&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#code-libraries" id="toc-entry-7"&gt;4.1 Code Libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hardware-hook-up-and-design" id="toc-entry-8"&gt;5.0 Hardware Hook Up and Design&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#instrumented-ebike-platform" id="toc-entry-9"&gt;5.1 Instrumented Ebike Platform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#electrical-hook-up" id="toc-entry-10"&gt;5.2 Electrical Hook Up&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#electronics-housings" id="toc-entry-11"&gt;5.3 Electronics Housings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#dead-mans-switch" id="toc-entry-12"&gt;5.4 Dead Man’s Switch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#throttle-relay-planned" id="toc-entry-13"&gt;5.5 Throttle Relay (Planned)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#bill-of-materials" id="toc-entry-14"&gt;6.0 Bill of Materials&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#suggested-improvements" id="toc-entry-15"&gt;7.0 Suggested Improvements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#acknowledgements" id="toc-entry-16"&gt;8.0 Acknowledgements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-1"&gt;1.0 Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The overall goal of this project is to design and implement a cruise control
system for an instrumented ebike used for conducting bicycle handling
experiments. A previous blog post &lt;a class="reference external" href="https://mechmotum.github.io/blog/ebike-controller-design.html"&gt;(found here)&lt;/a&gt; outlines the design and analysis of a
continuous time PID controller for controlling the speed of the ebike. This
blog post tells the story of how the designed PID controller was implemented
digitally on the instrumented ebike through an Arduino Nano and how it fits
into the ebike cruise control system that was developed to make functional use
of the PID controller.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="system-operation-functionality"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-2"&gt;2.0 System Operation &amp;amp; Functionality&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The implementation of the cruise control system on the electric bike was
fundamentally informed by the interactions the user would have with the system.
A typical user interaction with the system is outlined in Figure 1 below.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="User Interaction." src="https://objects-us-east-1.dream.io/mechmotum/UserInteractionFlowChart.jpg" style="width: 60%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 1. A typical user interaction with the system.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This user interaction flowchart was used to help better understand the problem
of implementing the cruise control system and sculpt the concepts for the
hardware and software portions of the cruise control system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="system-architecture"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-3"&gt;3.0 System Architecture&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="control-architecture"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-4"&gt;3.1 Control Architecture&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The control architecture is a simple negative feedback design that computes the
error between a user defined setpoint and the actual speed of the ebike. Figure
2 graphically shows how the control architecture is implemented on the ebike.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Control Architecture." src="https://objects-us-east-1.dream.io/mechmotum/BlogPost2ControlArchitecture.jpg" style="width: 60%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 2. Control architecture as implemented on the ebike.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="physical-architecture"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-5"&gt;3.2 Physical Architecture&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;At the heart of the cruise control system’s physical architecture is its
integration into the instrumented ebike’s powertrain. Figure 3 shows this
integration by highlighting the input/output and geometric relationships
between existing components of the ebike and the additional components needed
to implement the cruise control system.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="System Architecture." src="https://objects-us-east-1.dream.io/mechmotum/ControlSystemGeometricLayout.jpg" style="width: 75%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 3. Geometric layout of the system components showing relative size,
location, information flow, and type of each component. Components called
out with a triangle are existing components on the ebike. Components called
out with a circle are components that are introduced to the ebike system to
implement the cruise control.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The fundamental interaction between the control system and the existing ebike
powertrain system occurs at the interface between the Arduino nano and the
ebike motor controller. While the cruise control is engaged, the function of
the Arduino is to take control of the throttle signal away from the user by
passing the calculated output of the control loop to the motor controller
instead of the throttle position commanded by the rider. When the cruise
control is disengaged, the Arduino simply reads the user commanded throttle
position and passes it directly to the motor controller. Figure 4, below,
graphically shows this interaction.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Arduino's Main Function." src="https://objects-us-east-1.dream.io/mechmotum/ArduinoThrottleSchematic.jpg" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 4. Schematic showing the Arduino’s function as a throttle emulator.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;Note: Testing of the cruise control system has shown the implementation method
shown in Figure 4 to be inadequate while the cruise control is disengaged. The
time required for the Arduino to read and then write the signal it receives
from the throttle leads to unresponsive manual speed control while the cruise
control is disengaged. A fix to this issue is proposed in section 5.5 of this
blog post.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="software"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-6"&gt;4.0 Software&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The cruise control system software was written in C using the Arduino IDE.
Based on user inputs from two momentary pushbuttons, the software decides
whether or not to pass the throttle signal as an output or compute a throttle
output based on the PID controller. The software also updates the user on the
current status of the system via an LCD and logs diagnostic information to an
SD card.&lt;/p&gt;
&lt;p&gt;Figure 5, below, shows a high level view of the logic flow of the code.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Code Logic Flowchart." src="https://objects-us-east-1.dream.io/mechmotum/ControlSystemCodeLogicFlowChart.jpg" style="width: 100%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 5. Basic logic flowchart of the cruise control software.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Source code, and more details about it, can be found on the Laboratorium’s
Github repository &lt;a class="reference external" href="https://github.com/mechmotum/eBikeSpdController"&gt;found here&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="code-libraries"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-7"&gt;4.1 Code Libraries&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The continuous time PID controller derived in part one of this blog post series
was digitized on the Arduino Nano using Brett Beauregard’s PID_v1 library
&lt;a class="reference external" href="https://github.com/br3ttb/Arduino-PID-Library"&gt;(found here)&lt;/a&gt;. This library
was developed by Brett to implement continuous time PID controllers on Arduino
microcontrollers.&lt;/p&gt;
&lt;p&gt;Brett’s library was chosen to implement the PID controller because of its many
robust features such as Derivative Kick and Initialization. Additionally, this
library contains fantastic documentation which can be &lt;a class="reference external" href="http://brettbeauregard.com/blog/2011/04/improving-the-beginners-pid-introduction/"&gt;found here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To avoid slowing the code’s main loop, interrupts were used to manage the
change in setpoint brought on by a press of the speed increment decrement
buttons. Using interrupts free’s up the Arduino’s processor from having to
check whether or not there’s been a button press on every loop iteration.
Instead, the processor reacts to pin changes and interrupts the execution of
the main code to perform the function tied to the interrupt pin. However, the
Arduino Nano only has a limited number of pins that can be used as interrupts.
A library, written by GreyGnome &lt;a class="reference external" href="https://github.com/GreyGnome/PinChangeInt"&gt;(found here)&lt;/a&gt;, enables the use of interrupts
on any pin of the Arduino Nano. This library was used to free up pin real
estate for the many components that are wired up to the Arduino.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="hardware-hook-up-and-design"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-8"&gt;5.0 Hardware Hook Up and Design&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="instrumented-ebike-platform"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-9"&gt;5.1 Instrumented Ebike Platform&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Jason Moore, the lab’s PI, originally began constructing the instrumented ebike
platform in 2009 from a large Surly single speed off road steel frame bicycle
converted to an ebike with a conversion kit sold by Amped Bikes. The Amped
Bikes kit consists of a brushless direct drive hub motor driven by a motor
controller and powered by a 36V Li ion battery. More information on the build
and the bike’s instrumentation system can be found in Jason’s dissertation
&lt;a class="reference external" href="http://moorepants.github.io/dissertation/davisbicycle.html"&gt;found here&lt;/a&gt;.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Instrumented Ebike." src="https://objects-us-east-1.dream.io/mechmotum/TheInstrumentedEbike.JPG" style="width: 45%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 6. The instrumented ebike today.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="electrical-hook-up"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-10"&gt;5.2 Electrical Hook Up&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The electrical components of the control system revolve around an Arduino Nano
which is the central processor for the hardware and logic of the cruise control
system. Table 1, below, shows a complete list of the hardware used in this
build.&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;&lt;em&gt;Table 1. Table of components used in the control system. Prices and sources for each component can be found in the Bill of Materials in section 6.0.&lt;/em&gt;&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="40%" /&gt;
&lt;col width="40%" /&gt;
&lt;col width="20%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Component Name&lt;/th&gt;
&lt;th class="head"&gt;Details&lt;/th&gt;
&lt;th class="head"&gt;Function&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Arduino Nano&lt;/td&gt;
&lt;td&gt;ATmega328P Processor&lt;/td&gt;
&lt;td&gt;Main   Processor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Wheel Speed Sensor&lt;/td&gt;
&lt;td&gt;DC generator in contact with rear tire &lt;a class="reference external" href="http://moorepants.github.io/dissertation/davisbicycle.html"&gt;(Click here for more information)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Control Loop Input&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Voltage Divider&lt;/td&gt;
&lt;td&gt;Used to step down wheel speed sensor voltage to a range measurable by the Arduino&lt;/td&gt;
&lt;td&gt;Wheel Speed Sensor Signal Conditioning&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Pushbuttons&lt;/td&gt;
&lt;td&gt;Momentary pushbuttons to get user input&lt;/td&gt;
&lt;td&gt;User Input&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Battery&lt;/td&gt;
&lt;td&gt;7.2V NiCd&lt;/td&gt;
&lt;td&gt;System Power&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;LCD&lt;/td&gt;
&lt;td&gt;16x2 character LCD&lt;/td&gt;
&lt;td&gt;User Feedback&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Motor Controller&lt;/td&gt;
&lt;td&gt;Amped Bikes motor controller&lt;/td&gt;
&lt;td&gt;Control Loop Output&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;SD Card Module&lt;/td&gt;
&lt;td&gt;SPI SD card module for Arduino&lt;/td&gt;
&lt;td&gt;Data Logging&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The Arduino Nano and the voltage divider circuits were soldered to a small 3&amp;quot; x
1&amp;quot; piece of protoboard. Wires (22 AWG) were soldered to the protoboard to
connect the external components to the Nano. Figure 7 shows the completed
Arduino board.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Arduino Board." src="https://objects-us-east-1.dream.io/mechmotum/ArduinoBoardWiredUp.JPG" style="width: 60%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 7. The Arduino board with wires attached.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;With many of the components located on the handlebars, a majority of these
wires were routed together along the top tube, up the head tube and stretched
across to the handlebars. This task was facilitated using spiral wound cable
housings, zip ties, and a 15 pin Molex connector. Once on the handlebars, wires
were connected to header pins on the LCD and pushbuttons with Dupont
connectors.&lt;/p&gt;
&lt;p&gt;T-tap wire splices were used to cleanly splice power signals from the NiCd
battery above the Arduino near the top tube and from the wheel speed sensor
near the bottom bracket.&lt;/p&gt;
&lt;p&gt;A complete wiring schematic of the cruise control system can be found on the
laboratorium’s github &lt;a class="reference external" href="https://github.com/mechmotum/eBikeSpdController"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="electronics-housings"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-11"&gt;5.3 Electronics Housings&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Housings for the Arduino Nano, pushbuttons and LCD were designed and 3D printed
to enclose the electrical components and mount them to the ebike. Figure 8
shows the CAD model design of the Arduino housing. The housing’s design
includes pins for press fitting the Arduino stripboard to the mount. Slots on
the sides and top of the housing allow for wires to exit towards their
destinations on the ebike. Threaded inserts on the base are used to secure the
top cover using M3 screws.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Arduino Housing." src="https://objects-us-east-1.dream.io/mechmotum/ArduinoHousingDesign.jpg" style="width: 100%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 8. Arduino housing design.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The Arduino housing is clamped to the downtube of the ebike by a socket head
screw as shown in Figure 9.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Arduino Mounting." src="https://objects-us-east-1.dream.io/mechmotum/ArduinoHousingMountingPoints.JPG" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 9. Arduino housing mounting point.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Both the LCD and button housings were 3D printed and designed to mount to the
handlebars using a clamshell style mount used for securing GoPro cameras to
bikes. Each mount had a pair of “bunny ears&amp;quot; designed to interface with the
GoPro style mount. The LCD housing, shown in Figure 10 below, is a simple
rectangular two-piece enclosure joined by button head screws.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="LCD Housing." src="https://objects-us-east-1.dream.io/mechmotum/LCDHousingDesign.jpg" style="width: 75%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 10. LCD housing design.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Similar to the LCD housing, the button housing is a two-piece, enclosure joined
by screws. Inside the housing is a small piece of protoboard that the
pushbuttons are soldered to. To make pressing the mini momentary pushbuttons
more convenient for the user, larger button parts were 3D printed and offset
from each mini momentary pushbutton using a compression spring as shown in
Figure 11 below.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Button Housing." src="https://objects-us-east-1.dream.io/mechmotum/ButtonHousingDesign.jpg" style="width: 100%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 11. Button housing design.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;As shown in Figure 12, the button housing is mounted on the right side of the
handlebars near the throttle and brake lever for convenient access.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Button Housing Mount." src="https://objects-us-east-1.dream.io/mechmotum/ButtonHousingPosition.JPG" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 12. Button housing position on the handlebars.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="dead-mans-switch"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-12"&gt;5.4 Dead Man’s Switch&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For safety reasons, a dead man’s switch was added to the cruise control system.
The dead man’s switch works by cutting power from the Li+ battery through a
mechanical relay. The relay’s coil is connected to a power circuit having a
Reed switch. The Reed switch is actuated by a magnet strapped to the rider’s
ankle. If the rider were to remove their ankle from the foot peg, separating
the ankle magnet from the Reed switch, power to relay’s coil would be
interrupted, opening the Li+ battery circuit. Sheet five of the master
electrical schematic shows how the switch is wired up to the ebike’s
powertrain.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="throttle-relay-planned"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-13"&gt;5.5 Throttle Relay (Planned)&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Currently, when cruise control is disengaged, the time it takes the Arduino to
read the throttle signal and then write it to the motor controller is leading
to a jerky ride. This is likely due to the intermittency in the throttle signal
output to the motor controller produced by the delay in reading and writing the
throttle signal through the Arduino. Placing a relay in line with the throttle
signal will provide a continuous signal flow to the motor controller by
eliminating the need to read and then write that signal when it passes through
the Arduino. A continuous signal flow will eliminate the intermittency issues
that make the bike feel jerky when the cruise control is disengaged.&lt;/p&gt;
&lt;p&gt;Current plans for the relay have it placed inline with the throttle signal wire
and switched by the Arduino through its digital write function. The proposed
changes to the wiring schematic and software can be found on the project’s
Github repository under the “relay” branch. Plans for the physical
implementation of the relay include placing the relay on a piece of protoboard
mounted to the bike’s top tube,inside the upper head tube triangle.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="bill-of-materials"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-14"&gt;6.0 Bill of Materials&lt;/a&gt;&lt;/h2&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Bill of Materials." src="https://objects-us-east-1.dream.io/mechmotum/ControlSystemBillofMaterials.jpg" style="width: 100%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Table 2. Bill of materials (BOM) showing each part of project, where it was
purchased, what quantity was purchased and its cost.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="suggested-improvements"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-15"&gt;7.0 Suggested Improvements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Throughout the implementation of this design, I've made note of some
improvements to the system's hardware design that could be made to address
known issues. I have listed these below:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Use a display that communicates via the SPI protocol to reduce the number of
wires used&lt;/li&gt;
&lt;li&gt;For the Arduino board, use a custom PCB and connectors to increase the
robustness of the board&lt;/li&gt;
&lt;li&gt;Implement a throttle relay (See section 5.5)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here are some avenues for improving the accuracy and precision of the cruise
control:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Set a faster sampling time in the PID Arduino library&lt;/li&gt;
&lt;li&gt;Replace DC generator wheel speed sensor with a rotary encoder for smoother
speed input (and preservation of the rear tire)&lt;/li&gt;
&lt;li&gt;Experiment with manual PID parameter tuning during outdoor testing to improve
output surging while cruise control is engaged&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="acknowledgements"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-16"&gt;8.0 Acknowledgements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I would like to thank &lt;a class="reference external" href="https://github.com/ngchan"&gt;Nicholas Chan&lt;/a&gt; for writing
the camera gimbal software that my speed control software is based off of. I’d
also like to thank &lt;a class="reference external" href="https://github.com/br3ttb"&gt;Brett Beuaregard&lt;/a&gt; for writing
the PID library and it’s excellent documentation that is the heart of the speed
control software. Finally, I’d like to thank Jason Moore for his support and
mentorship throughout this project.&lt;/p&gt;
&lt;/div&gt;
</content><category term="research"/><category term="bicycle"/><category term="engineering"/><category term="controller implementation"/><category term="arduino"/></entry><entry><title>Practical Realization of a Theoretical Optimal-Handling Bicycle Results</title><link href="https://mechmotum.github.io/blog/practical-realization-of-a-theoretical-optimal-handling-bicycle-results.html" rel="alternate"/><published>2019-10-03T00:00:00-07:00</published><updated>2019-10-03T00:00:00-07:00</updated><author><name>Anthony Toribio</name></author><id>tag:mechmotum.github.io,2019-10-03:/blog/practical-realization-of-a-theoretical-optimal-handling-bicycle-results.html</id><summary type="html">&lt;p class="first last"&gt;Blog post on the design and fabrication of a theoretically optimal
handling bicycle&lt;/p&gt;
</summary><content type="html">&lt;p&gt;The goal of this research is to design and fabricate a theoretically optimal
lateral handling bicycle based on a dynamics based algorithm written by
Professor Moore. Lateral handling is quantified using the Handling Quality
Metric (HQM) where lower peak values indicate better handling. This
optimization algorithm takes into account physical bicycle properties including
geometry, mass, moments of inertia and speed. In particular, the geometry
defining the bicycle's trail, wheelbase, steer axis tilt, and front wheel
radius are optimized for the target speed.&lt;/p&gt;
&lt;p&gt;Our measure of lateral handling difficulty is the theoretical handling quality
metric (HQM). HQM is a function of frequency and quantifies the human control
effort needed to stabilize and direct a given bicycle based on quantifying the
rider's roll rate sensing activity. We then followed an iterative design
process to develop physically realizable wheels, frame, and fork that will
produce parameter values as close as possible to the target optimal parameter
values. We then fabricated and test rode the resulting bicycle.&lt;/p&gt;
&lt;p&gt;A theoretical target bicycle design has been found using the algorithm at a
speed of 3m/s with an HQM of 1.2 as compared to a standard bicycle's HQM of 7.8
at the same speed. Once a realizable model was created in CAD, the HQM was seen
to rise from 1.2 to 2.45. This value far surpasses the standard bicycle.
However, the fabrication of the design proved to be rather challenging. Issues
were encountered with tolerances and therefore error propagation as well as
issues with deflection under loading. These issues in combination created a
fabricated bicycle dissimilar to the original model. The fabricated bicycle
yielded an HQM with close-loop instability meaning that the handling could not
be evaluated using the algorithm.&lt;/p&gt;
&lt;p&gt;The bicycle was test ridden by Stasia and determined to have characteristics
described as &amp;quot;stable and effortless to ride when the intent is not to steer in
a particular direction&amp;quot;. Riding the bicycle felt &amp;quot;stable, as if you are sitting
in a cart&amp;quot;. Even though the bicycle is unstable in the algorithm, a real rider
can control it. For more information on the current status of this research,
please see the attached paper and media below. Future work on this research
will be to evaluate the handling of the bicycle both subjectively and
objectively.&lt;/p&gt;
&lt;p&gt;Paper: &lt;a class="reference external" href="https://doi.org/10.6084/m9.figshare.9883328.v1"&gt;https://doi.org/10.6084/m9.figshare.9883328.v1&lt;/a&gt;&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="3ms Fabricated." src="https://objects-us-east-1.dream.io/mechmotum/3ms-fabricated.jpg" style="width: 50%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 1. Fabricated model of optimal bicycle for 3 m/s.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="3ms Fabricated Rider." src="https://objects-us-east-1.dream.io/mechmotum/3ms-fabricated-rider.jpg" style="width: 50%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 2. Fabricated model of optimal bicycle for 3 m/s with rider.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;iframe width="560" height="315"
src="https://www.youtube.com/embed/oDPssZu9Uso" frameborder="0"
allow="accelerometer; autoplay; encrypted-media; gyroscope;
picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;</content><category term="research"/><category term="bicycle"/><category term="design"/><category term="handling qualities"/><category term="control"/><category term="optimization"/><category term="fabrication"/></entry><entry><title>Ski Jump Design Software to Analyze User Inputted Jumps</title><link href="https://mechmotum.github.io/blog/skijumpdesign-analysis.html" rel="alternate"/><published>2019-04-18T00:00:00-07:00</published><updated>2019-04-18T00:00:00-07:00</updated><author><name>Bryn Cloud</name></author><id>tag:mechmotum.github.io,2019-04-18:/blog/skijumpdesign-analysis.html</id><summary type="html">&lt;p class="first last"&gt;Blog post on adding page to skijumpdesign app to analyze user inputted
ski jumps for equivalent fall height.&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The goal of this work is to add a new page to the &lt;a class="reference external" href="http://www.skijumpdesign.info"&gt;Ski Jump Design Tool&lt;/a&gt;
that allows users to input a measured jump profile and get a depiction of
the equivalent fall height (EFH) for their jump. Figure 1 illustrates the
components of a terrain park using common terminology.&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Ski Jump Terminology." src="https://objects-us-east-1.dream.io/mechmotum/ski-figure-01.png" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 1. Components of standard terrain park jump from [Levy]_.
Reprinted with the author's permission.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;The software is designed for users with little to no technical background,
and guides the users through correct implementation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="calculating-equivalent-fall-height"&gt;
&lt;h2&gt;Calculating Equivalent Fall Height&lt;/h2&gt;
&lt;p&gt;The theory of equivalent fall height calculations has been discussed by &lt;a class="citation-reference" href="#levy" id="citation-reference-1"&gt;[Levy]&lt;/a&gt;.
EFH can be expressed as follows:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
h = \frac{v_j^2sin^2(\theta_J - \theta_L)}{2g}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(v_j\)&lt;/span&gt; is the jumper's landing speed, &lt;span class="math"&gt;\(\theta_J\)&lt;/span&gt; is the
jumper's landing angle, &lt;span class="math"&gt;\(\theta_L\)&lt;/span&gt; is the slope angle and &lt;span class="math"&gt;\(g\)&lt;/span&gt; is
gravity. This calculation was added to the skijumpdesign software to evaluate
the EFH of any surface. A takeoff angle, skier instance, and a takeoff point
relative to the surface are user inputs to the function. Then, the function
uses these inputs to find the skier's impact velocity at each point along the
surface and extracts the skier's landing speed and landing angle. The slope
angle is calculated using the slope along the surface.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="measuring-a-jump-s-profile"&gt;
&lt;h2&gt;Measuring A Jump's Profile&lt;/h2&gt;
&lt;p&gt;A jump has been measured using the three following methods.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Use a tape measure and level to find the surface distance and angle at
defined points along the jump. Then, convert the values to planar Cartesian
coordinate system that lies on the jumps cross section.&lt;/li&gt;
&lt;li&gt;Mount a high precision differential GPS to a snowboard and slowly walk the
snowboard along the jump.&lt;/li&gt;
&lt;li&gt;Mount a differential GPS on a helmet and have a skier ski along the jump as
slowly as possible.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We spent time this quarter testing the latter. A Piksi differential GPS system
was used for the experiments. This system uses two receivers, the base and the
rover, and calculates the relative position between the two. This referencing
allows the differential GPS to have a one centimeter accuracy. The GNSS antenna
was mounted to a bike helmet by drilling a hole through the top and fastening
it down with a nut and bolt. The cable that connects the antenna to the rover
evaluation board was fed down the profile of the helmet and into a backpack.&lt;/p&gt;
&lt;p&gt;Preliminary tests were gathered using the helmet/backpack setup while a rider
biked around a neighborhood in Davis. We found that while the rider was biking,
there were a lot of obstructions that would make the rover and base station
lose their fixed position when they were more than ~400 meters apart. This
meant that we were still able to locate the rover, but it had a less accurate
reading. We felt confident that we could maintain a fixed, accurate position
for at least 350 meters, so we spent the next weekend testing the setup at
Sierra at Tahoe ski resort.&lt;/p&gt;
&lt;p&gt;The skier went down four different jumps while the recorder was with the base
station left at the bottom of the resort. After the recorder started recording,
the skier slowly rode up the takeoff of the jump. Once at the top of takeoff,
the skier stopped and side stepped the takeoff lip. This method was used so
that it is easier to take note of where the takeoff point of the jump is when
we analyzed the data. After the sidestep, the skier stepped off the takeoff lip
and slowly rode down the landing profile. We tested 2 jump lines, one
approximately 200 meters from the base station, and one 1000 meters from the
base station. We found that the differential GPS accurately measured at both
locations, which was a pleasant surprise after the testing on a bike. This data
shows promise for this jump profiling method. Figure 2 shows me (the skier)
with the differential GPS ski helmet, and the backpack strapped to my chest.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Differential GPS Skier Helmet." src="https://objects-us-east-1.dream.io/mechmotum/ski-figure-02.jpg" style="width: 50%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 2. A differential GPS mounted to a helmet for testing at Sierra at Tahoe.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="ski-jump-application-update"&gt;
&lt;h2&gt;Ski Jump Application Update&lt;/h2&gt;
&lt;p&gt;The new version of the ski jump web application has launched and is available
at &lt;a class="reference external" href="http://www.skijumpdesign.info"&gt;http://www.skijumpdesign.info&lt;/a&gt;. A home page was added to keep it user
friendly. This is shown below.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Ski Jump Tool Home Page." src="https://objects-us-east-1.dream.io/mechmotum/ski-figure-03.png" style="width: 50%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 3. New Ski Jump Web Application - Home Page.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The buttons centered in the middle of this page will direct users to the ski
jump design or the new analysis page shown in Figure 4.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Ski Jump Tool Analysis." src="https://objects-us-east-1.dream.io/mechmotum/ski-figure-06.png" style="width: 50%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 4. New Ski Jump Web Application - Analysis Page.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;An example of a jump designed with a takeoff angle of 10 degrees and maximum
equivalent fall height of 0.8 m is displayed when the page is loaded. The user
can see the jump profile, EFH value, and knee collapse and possible soft
landing EFH values. The calculation shows a constant EFH value of 0.8 m until
it reaches the landing transition surface. Instead, the ski jump design app
limits the acceleration felt by the skier - which is the reason for the spike
in EFH.  From there, the user can scroll down to the input box to upload their
own jump. This input box is shown in Figure 5 with a sample csv file uploaded.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Analysis Input Box." src="https://objects-us-east-1.dream.io/mechmotum/ski-figure-07.png" style="width: 50%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 5. Analysis Page Input Box.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;A function was added to the skijumpdesign software to calculate the equivalent
fall height of a surface. A differential GPS mounted on a skier's helmet is a
promising way to measure a jump profile because it is portable and efficient.
The ski jump web application has expanded to showcase three pages: a home page,
design page, and analysis page. Further work is needed to speed up the
calculations, determine the best methods for users to measure a jump, and make
the new web app user friendly.&lt;/p&gt;
&lt;p&gt;Other related information:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Web application: &lt;a class="reference external" href="http://www.skijumpdesign.info"&gt;http://www.skijumpdesign.info&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Software repository: &lt;a class="reference external" href="https://gitlab.com/moorepants/skijumpdesign"&gt;https://gitlab.com/moorepants/skijumpdesign&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Software documentation: &lt;a class="reference external" href="http://skijumpdesign.readthedocs.io"&gt;http://skijumpdesign.readthedocs.io&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;table class="docutils citation" frame="void" id="levy" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#citation-reference-1"&gt;[Levy]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Levy, D., Hubbard, M., McNeil, J.A. et al. Sports Eng (2015) 18: 227.
&lt;a class="reference external" href="https://doi.org/10.1007/s12283-015-0182-6"&gt;https://doi.org/10.1007/s12283-015-0182-6&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="research"/><category term="ski"/><category term="sports"/><category term="engineering"/><category term="safety"/></entry><entry><title>Implementation of a PID Controller for Controlling The Speed of an Instrumented Ebike</title><link href="https://mechmotum.github.io/blog/ebike-controller-implementation.html" rel="alternate"/><published>2019-04-05T00:00:00-07:00</published><updated>2019-04-05T00:00:00-07:00</updated><author><name>Trevor Metz</name></author><id>tag:mechmotum.github.io,2019-04-05:/blog/ebike-controller-implementation.html</id><summary type="html">&lt;p class="first last"&gt;Blog post on the implementation of a PID controller on an
instrumented ebike&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;em&gt;This blog post has been updated in a newer blog post. Please see the updated version of this blog post for the most up to date information.&lt;/em&gt;&lt;/p&gt;
&lt;div class="contents floatcon local topic" id="table-of-contents"&gt;
&lt;p class="topic-title"&gt;&lt;a class="reference internal" href="#top"&gt;Table of Contents&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#introduction" id="toc-entry-1"&gt;1.0 Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-operation-functionality" id="toc-entry-2"&gt;2.0 System Operation &amp;amp; Functionality&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#system-architecture" id="toc-entry-3"&gt;3.0 System Architecture&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#control-architecture" id="toc-entry-4"&gt;3.1 Control Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#physical-architecture" id="toc-entry-5"&gt;3.2 Physical Architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#software" id="toc-entry-6"&gt;4.0 Software&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#code-libraries" id="toc-entry-7"&gt;4.1 Code Libraries&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#hardware-hook-up-and-design" id="toc-entry-8"&gt;5.0 Hardware Hook Up and Design&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference internal" href="#instrumented-ebike-platform" id="toc-entry-9"&gt;5.1 Instrumented Ebike Platform&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#electrical-hook-up" id="toc-entry-10"&gt;5.2 Electrical Hook Up&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#electronics-housings" id="toc-entry-11"&gt;5.3 Electronics Housings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#bill-of-materials" id="toc-entry-12"&gt;6.0 Bill of Materials&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#lessons-learned-and-suggested-improvements" id="toc-entry-13"&gt;7.0 Lessons Learned and Suggested Improvements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#acknowledgements" id="toc-entry-14"&gt;8.0 Acknowledgements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-1"&gt;1.0 Introduction&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The overall goal of this project is to design and implement a control system
for an instrumented ebike used in bicycle handling experimentation. A previous
blog post found &lt;a class="reference external" href="ebike-controller-design"&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;outlines the design and analysis of a PID controller that meets the steady
state error goal of +/- 0.1m/s. This blog post tells the story of how the
designed PID controller was implemented on the instrumented ebike using an
Arduino Nano.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="system-operation-functionality"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-2"&gt;2.0 System Operation &amp;amp; Functionality&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The implementation of the PID controller on the electric bike was fundamentally
informed by the interactions that the user would have with the system. A
typical user interaction with the system is outlined in Figure 1 below.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="User Interaction." src="https://objects-us-east-1.dream.io/mechmotum/UserInteractionFlowChart.jpg" style="width: 60%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 1. A typical user interaction with the system.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This user interaction flowchart was used to help better understand the problem
and sculpt the concept for the hardware and software design of the speed
control system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="system-architecture"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-3"&gt;3.0 System Architecture&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="control-architecture"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-4"&gt;3.1 Control Architecture&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The control architecture is a simple feedback design that computes the error
between a user defined setpoint and compares it to the speed of the ebike as
measured via a DC generator wheel speed sensor (more on this in section 5.2).
Figure 2, shows how this error is inputted to the control algorithm encoded in
the Arduino Nano resulting in an output variable used to control the speed of
the ebike.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Control Architecture." src="https://objects-us-east-1.dream.io/mechmotum/BlogPost2ControlArchitecture.jpg" style="width: 60%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 2. Control architecture.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="physical-architecture"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-5"&gt;3.2 Physical Architecture&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;At the heart of the control system’s physical architecture is its integration
into the existing instrumented ebike platform.  Figure 3, below, shows this
integration by highlighting the input/output and geometric relationships
between existing components of the ebike and the additional control system
components.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="System Architecture." src="https://objects-us-east-1.dream.io/mechmotum/ControlSystemGeometricLayout.jpg" style="width: 75%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 3. Geometric layout of the system components showing relative size,
location, information flow, and type of each component. Components called
out with a triangle are existing components on the ebike. Components called
out with a circle are components that are introduced to the ebike system to
implement the controller.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The fundamental interaction between the control system and the existing ebike
powertrain system occurs at the interface between the Arduino nano and the
ebike motor controller. While the cruise control is engaged, the function of
the Arduino is to take control of the throttle signal away from the user and
pass it through the control algorithm before sending it to the motor
controller. When the cruise control is disengaged, the Arduino simply reads the
user commanded throttle position and passes it directly to the motor
controller.  Figure 4, below, graphically shows this interaction.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Arduino's Main Function." src="https://objects-us-east-1.dream.io/mechmotum/ArduinoThrottleSchematic.jpg" style="width: 40%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 4. Schematic showing the Arduino’s function as a throttle emulator.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="software"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-6"&gt;4.0 Software&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The control system software was written in C using the Arduino IDE. Based on
user inputs from two momentary pushbuttons, the software decides whether or not
to pass the throttle signal as an output or compute a throttle output based on
the PID controller. The software also updates the user on the current status of
the system via an LCD and logs diagnostic information to an SD card.&lt;/p&gt;
&lt;p&gt;Figure 5, below, shows the logic flow of the code.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Code Logic Flowchart." src="https://objects-us-east-1.dream.io/mechmotum/ControlSystemCodeLogicFlowChart.jpg" style="width: 100%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 5. Code logic flowchart.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The software, and more details about it, can be found on the Laboratorium’s
Github repository &lt;a class="reference external" href="https://github.com/mechmotum/eBikeSpdController"&gt;found here&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="code-libraries"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-7"&gt;4.1 Code Libraries&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The continuous time PID controller derived in part one of this blog post series
was digitized on the Arduino Nano using Brett Beauregard’s PID_v1 library
&lt;a class="reference external" href="https://github.com/br3ttb/Arduino-PID-Library"&gt;(found here)&lt;/a&gt;. This library
was developed by Brett to implement PID controllers on an Arduino
microcontroller.&lt;/p&gt;
&lt;p&gt;Brett’s library was chosen to implement the PID controller because of its many
robust features such as Derivative Kick and Initialization.  Additionally, this
library contains fantastic documentation which can be &lt;a class="reference external" href="http://brettbeauregard.com/blog/2011/04/improving-the-beginners-pid-introduction/"&gt;found here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To avoid slowing the code’s main loop, interrupts were used to manage the
change in setpoint brought on by a press of the speed increment decrement
buttons. Using interrupts free’s up the Arduino’s processor from having to
check whether or not there’s been a button press on every loop iteration.
Instead, the processor reacts to pin changes and interrupts the execution of
the main code to perform the function tied to the interrupt pin. However, the
Arduino Nano only has a limited number of pins that can be used as interrupts.
A library, written by GreyGnome &lt;a class="reference external" href="https://github.com/GreyGnome/PinChangeInt"&gt;(found here)&lt;/a&gt;, enables the use of interrupts
on any pin of the Arduino Nano.  This library was used to free up pin real
estate for the many components that are wired up to the Arduino.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="hardware-hook-up-and-design"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-8"&gt;5.0 Hardware Hook Up and Design&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="instrumented-ebike-platform"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-9"&gt;5.1 Instrumented Ebike Platform&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Jason Moore, the lab’s PI, originally began constructing the instrumented ebike
platform in 2009 from a large Surly single speed off road steel frame bicycle
converted to an ebike with a conversion kit sold by Amped Bikes. The Amped
Bikes kit consists of a brushless direct drive hub motor driven by a motor
controller and a 36V Li ion battery. More information on the build and the
bike’s instrumentation system can be found in Jason’s dissertation &lt;a class="reference external" href="http://moorepants.github.io/dissertation/davisbicycle.html"&gt;found here&lt;/a&gt;.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Instrumented Ebike." src="https://objects-us-east-1.dream.io/mechmotum/TheInstrumentedEbike.JPG" style="width: 45%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 6. The instrumented ebike today.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="electrical-hook-up"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-10"&gt;5.2 Electrical Hook Up&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The electrical components of the control system revolve around an Arduino Nano
which is used to process inputs and outputs to human interface hardware,
actuators, and logging hardware. Table 1, below, shows a complete list of the
hardware used in this build.&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;caption&gt;&lt;em&gt;Table 1. Table of components used in the control system. Prices and sources for each component can be found in the Bill of Materials in section 6.0.&lt;/em&gt;&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col width="40%" /&gt;
&lt;col width="40%" /&gt;
&lt;col width="20%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Component Name&lt;/th&gt;
&lt;th class="head"&gt;Details&lt;/th&gt;
&lt;th class="head"&gt;Function&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Arduino Nano&lt;/td&gt;
&lt;td&gt;ATmega328P Processor&lt;/td&gt;
&lt;td&gt;Main   Processor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Wheel Speed Sensor&lt;/td&gt;
&lt;td&gt;DC generator in contact with rear tire &lt;a class="reference external" href="http://moorepants.github.io/dissertation/davisbicycle.html"&gt;(Click here for more information)&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Control Loop Input&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Voltage Divider&lt;/td&gt;
&lt;td&gt;Used to step down wheel speed sensor voltage to a range measurable by the Arduino&lt;/td&gt;
&lt;td&gt;Wheel Speed Sensor Signal Conditioning&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Pushbuttons&lt;/td&gt;
&lt;td&gt;Momentary pushbuttons to get user input&lt;/td&gt;
&lt;td&gt;User Input&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Battery&lt;/td&gt;
&lt;td&gt;7.2V NiCd&lt;/td&gt;
&lt;td&gt;System Power&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;LCD&lt;/td&gt;
&lt;td&gt;16x2 character LCD&lt;/td&gt;
&lt;td&gt;User Feedback&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Motor Controller&lt;/td&gt;
&lt;td&gt;Amped Bikes motor controller&lt;/td&gt;
&lt;td&gt;Control Loop Output&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;SD Card Module&lt;/td&gt;
&lt;td&gt;SPI SD card module for Arduino&lt;/td&gt;
&lt;td&gt;Data Logging&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Figure 7, below, shows a Fritzing diagram of the electrical system.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Electrical Hookup." src="https://objects-us-east-1.dream.io/mechmotum/ControlSystemWiringDiagram.jpg" style="width: 60%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 7. Fritzing diagram of control system electronics. Note that the
motor controller is represented by a DC motor and the 7.2V NiCd battery is
represented by a 1S LiPo battery.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The Arduino Nano and the voltage divider circuits were soldered to a small 3&amp;quot; x
1.1&amp;quot; piece of stripboard. Wires, braided 22AWG, were soldered to the stripboard
to connect the external components to the Nano. Figure 8, below, shows the
completed Arduino board.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Arduino Board." src="https://objects-us-east-1.dream.io/mechmotum/ArduinoBoardWiredUp.JPG" style="width: 60%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 8. The Arduino board with wires attached.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;With many of the components located on the handlebars, a majority of these
wires were routed together along the top tube, up the head tube and stretched
across to the handlebars. This task was facilitated using spiral wound cable
housings, zip ties, and a 15 pin Molex connector. Once on the handlebars, wires
were connected to header pins on the LCD and pushbuttons with Dupont
connectors.&lt;/p&gt;
&lt;p&gt;Rearward of the Arduino, T-tap wire splices were used to cleanly splice power
signals from the NiCd battery above the Arduino near the top tube and from the
wheel speed sensor near the bottom bracket.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="electronics-housings"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#toc-entry-11"&gt;5.3 Electronics Housings&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Housings for the Arduino Nano, pushbuttons and LCD were designed and 3D printed
to enclose the electrical components and mount them to the ebike. Figure 9,
below, shows the CAD model design of the Arduino housing. The housing’s design
includes pins for press fitting the Arduino stripboard to the mount. Slots on
the sides and top of the housing allow for wires to exit towards their
destinations on the ebike. Threaded inserts on the base are used to secure the
top cover using M3 screws.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Arduino Housing." src="https://objects-us-east-1.dream.io/mechmotum/ArduinoHousingDesign.jpg" style="width: 100%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 9.  Arduino housing design.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;This housing is clamped to the downtube of the ebike by a socket head screw as
shown in Figure 10.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Arduino Mounting." src="https://objects-us-east-1.dream.io/mechmotum/ArduinoHousingMountingPoints.JPG" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 10. Arduino housing mounting point.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Both the LCD and button housings were 3D printed and designed to mount to the
handlebars using a clamshell style mount used for securing GoPro cameras to
bikes. Each mount had a pair of “bunny ears&amp;quot; designed to interface with the
GoPro style mount. The LCD housing, shown in Figure 11 below, is a simple
rectangular two-piece enclosure joined by button head screws.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="LCD Housing." src="https://objects-us-east-1.dream.io/mechmotum/LCDHousingDesign.jpg" style="width: 75%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 11. LCD housing design.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Similar to the LCD housing, the button housing is a two-piece, enclosure joined
by screws. Inside the housing is a small piece of stripboard that the
pushbuttons are soldered to. To make pressing the mini momentary pushbuttons
more convenient for the user, larger button parts were 3D printed and offset
from each mini momentary pushbutton using a compression spring as shown in
Figure 12 below.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Button Housing." src="https://objects-us-east-1.dream.io/mechmotum/ButtonHousingDesign.jpg" style="width: 100%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 12. Button housing design.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;As shown in Figure 13, the button housing is mounted on right side of the
handlebars near the throttle and brake lever for convenient access.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Button Housing Mount." src="https://objects-us-east-1.dream.io/mechmotum/ButtonHousingPosition.JPG" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 13. Button housing position on the handlebars.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="bill-of-materials"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-12"&gt;6.0 Bill of Materials&lt;/a&gt;&lt;/h2&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Bill of Materials." src="https://objects-us-east-1.dream.io/mechmotum/ControlSystemBillofMaterials.jpg" style="width: 100%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Table 2. Bill of materials (BOM) showing each part of project, where it was
purchased, what quantity was purchased and its cost.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="lessons-learned-and-suggested-improvements"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-13"&gt;7.0 Lessons Learned and Suggested Improvements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Throughout the process of implementing this controller, I learned some helpful
lessons when it comes to designing electronics  housings and doing electrical
hookups.&lt;/p&gt;
&lt;p&gt;Some lessons learned include the following:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;It is important to account for the minimum bend radius of each wire inside of
an electrical enclosure&lt;/li&gt;
&lt;li&gt;It is important to follow &lt;a class="reference external" href="https://www.lulzbot.com/learn/tutorials/heat-set-inserts-tips-and-tricks"&gt;best practices&lt;/a&gt;
when designing for heat set threaded inserts&lt;/li&gt;
&lt;li&gt;Iteration is required in order to achieve a design intent when 3D printing&lt;/li&gt;
&lt;li&gt;Test the assembly and function of electrical connections on scrap wire before
commiting changes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Throughout the implementation of this design, I've made note of some
improvements to the system's design that could be made. I have listed these
below:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A larger momentary pushbutton could be used to reduce the complexity of the
button housing and improve its functionality&lt;/li&gt;
&lt;li&gt;Use a display that communicates via the SPI protocol to reduce the number of
wires used&lt;/li&gt;
&lt;li&gt;For the Arduino board, use a custom PCB to increase the robustness of the
board&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="acknowledgements"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#toc-entry-14"&gt;8.0 Acknowledgements&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I would like to thank &lt;a class="reference external" href="https://github.com/ngchan"&gt;Nicholas Chan&lt;/a&gt; for writing
the camera gimbal software that my speed control software is based off of. I’d
also like to thank &lt;a class="reference external" href="https://github.com/br3ttb"&gt;Brett Beuaregard&lt;/a&gt; for writing
the PID library and it’s excellent documentation that is the heart of the speed
control software. Finally, I’d like to thank Jason Moore for his support and
mentorship throughout this project.&lt;/p&gt;
&lt;p&gt;Stay tuned for part three of this series: Testing and Validation&lt;/p&gt;
&lt;/div&gt;
</content><category term="research"/><category term="bikes"/><category term="engineering"/><category term="controller implementation"/><category term="arduino"/></entry><entry><title>Double Pendulum Human Controller Robot: GUI Development</title><link href="https://mechmotum.github.io/blog/double-pendulum-robot.html" rel="alternate"/><published>2019-02-11T00:00:00-08:00</published><updated>2019-02-11T00:00:00-08:00</updated><author><name>Jonathan Blaze Cubanski</name></author><id>tag:mechmotum.github.io,2019-02-11:/blog/double-pendulum-robot.html</id><summary type="html">&lt;p class="first last"&gt;Blog post on creating a new interface to test different controller
designs for the Double Pendulum Robot.&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="introduction-and-background"&gt;
&lt;h2&gt;Introduction and background&lt;/h2&gt;
&lt;p&gt;The Double Pendulum Biomimetic Project has the overarching goal of developing a
desktop-controlled inverted double pendulum with actuators in each joint to
serve as a model for a human balancing on a moving platform (i.e. a
skateboard), where the degrees of freedom is limited to the human’s waist and
ankle joints. This model is illustrated in Figure 1 below.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Image depicting visual model showing the dynamics of the double pendulum robot" src="https://objects-us-east-1.dream.io/mechmotum/pendulum-fbd.png" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 1: Double Pendulum Reference (Photo created by Erich Baur, Todd Sweeney, Jiahao Wei, Greg McDonald)&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;There are two key applications for such a device. Firstly, it can assist in
controller identification, helping bridge the gap between the simulation of
human movements and real-world data collection. Secondly, the project is done
in collaboration with the Dr. Zhaodan Kong and the Cyber Human Physical Systems
Lab— Dr. Kong intends to use the device to demonstrate the fundamentals of
control theory to school students.&lt;/p&gt;
&lt;p&gt;The pendulum hardware was developed previously by EME 185 students, as well as
some preliminary Arduino code to enable robot movement. The primary objectives
were now to bring this hardware to life with UI software with an interactive
GUI for the robot, and improve upon the embedded Arduino code. Additional
objectives included restoring and improving the electromechanical hardware as
needed, and allow data collection from the onboard encoders.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="software-development"&gt;
&lt;h2&gt;Software Development&lt;/h2&gt;
&lt;p&gt;The following presents a high-level overview of the software solutions that
were implemented. To make the code modular and user-friendly, 4 custom
libraries were developed to encapsulate all needed functionality. General
system operation functions and interrupts governing writing PWM signals,
tracking encoder positions, enforcing position limits, and computing system
states were isolated in a general functionality library. A separate library for
controllers allows the user to add or modify controllers for all actuators. In
order to send position and angle commands as a function of time, the user can
directly write mathematical functions into a dedicated position library in
inches, degrees, and seconds. It was determined that the educational value of
the system and the overall functionality would greatly benefit from real-time
gain updates and user control. To facilitate this, a serial processing library
was established and using the IDE Processing, a GUI was created. The GUI, as
shown below, has a startup and swing-up buttons which enable the user to safely
start system operation when ready. The user can select the desired motor
controller and update the gains in real time.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Operating GUI." src="https://objects-us-east-1.dream.io/mechmotum/pendulum-gui.png" style="width: 50%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 2. Operating GUI for Double Pendulum Operation&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="results-and-discussion"&gt;
&lt;h2&gt;Results and Discussion&lt;/h2&gt;
&lt;p&gt;The system currently is operating with PID controllers for each actuator and
the aforementioned functionality. The custom designed GUI successfully augments
the controller values and output response of the double pendulum robot. In the
video below, the robot is set to remain positioned perpendicular to the ground
as different external inputs are enacted onto the robot. The different PID
gains inputted into the GUI clearly affect its ability to return to that
position after being offset by external forces. Here is a link to a video that
showcases its performance.&lt;/p&gt;
&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/nCciGgxlK24" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;
&lt;div class="section" id="further-work"&gt;
&lt;h2&gt;Further Work&lt;/h2&gt;
&lt;p&gt;The current limiting factors of this system primarily relate to the state of
the hardware and certain design decisions. Testing of serial communication
indicates that there may be a systematic shielding issue, and the
microprocessor should be moved away from high voltage lines. It is also unclear
if the code is operating fast enough to achieve optimal performance. Thorough
testing of performance while increasing the delay between each loop is needed
to understand the effects of this. Including a feature to allow enter custom
controller algorithms to save, access and port these into the microcontroller
was also difficult to achieve within the time constraints allotted.&lt;/p&gt;
&lt;p&gt;Data collection using a serial monitoring application is currently possible by
printing encoder data to the terminal, however, this slows down the code since
serial writing is relatively slow. Without a clear understanding of the effects
of changing loop time, it is not possible to draw clear conclusions about the
implications of this. A viable solution would be to have a second Arduino
running in parallel which only prints serial data and does not command the
robot. More testing is needed.&lt;/p&gt;
&lt;p&gt;Here is the link to our GitHub Repository where you can find the Arduino .ino
code, the custom libraries to operate the robot, and the Processing IDE code
for the GUI controller.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/mechmotum/DoublePendulumCode"&gt;https://github.com/mechmotum/DoublePendulumCode&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="thank-you"&gt;
&lt;h2&gt;Thank you&lt;/h2&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="This image displays the two students that worked on this project over the Fall 2018 Quarter, Dorian Crutcher and Jonathan Blaze Cubanski" src="https://objects-us-east-1.dream.io/mechmotum/dorian-blaze.jpg" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 3: Left: Dorian Crutcher   Right: Jonathan Blaze Cubanski&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</content><category term="research"/><category term="controller"/><category term="double pendulum"/><category term="gui"/></entry><entry><title>Finding the Efficiency of the Xylem and Money Maker Treadle Pumps</title><link href="https://mechmotum.github.io/blog/treadle-pump-experiment.html" rel="alternate"/><published>2018-12-27T00:00:00-08:00</published><updated>2018-12-27T00:00:00-08:00</updated><author><name>Aaron Shaw</name></author><id>tag:mechmotum.github.io,2018-12-27:/blog/treadle-pump-experiment.html</id><summary type="html">&lt;p class="first last"&gt;Blog post on conducting efficiency experiments with treadle pumps.&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Small scale farmers use human-powered water pumps in rural areas to increase
crop yields beyond subsistence levels. Different designs utilize various
biomechanical motions. One of the most popular and proven designs for
human-powered water pumps is the treadle pump, which is operated via a stepping
motion (Figure 1).&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Treadle Example." src="https://objects-us-east-1.dream.io/mechmotum/treadle-example.jpg" style="width: 50%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 1. A user &amp;quot;treadles&amp;quot; on the Money Maker treadle pump.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The treadle pump is an inexpensive and portable irrigation tool. According to
International Development Enterprises (IDE), treadle pumps helped farmers in
Bangladesh increase their income by an average of $100 a year. This increase in
profit allowed farmers to invest in larger, more expensive irrigation machines
that further increased crop yields and helped create financial stability
&lt;a class="citation-reference" href="#polak" id="citation-reference-1"&gt;[Polak]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A prototype pedal-powered centrifugal water pump was tested by Abe McKay during
his Master’s studies &lt;a class="citation-reference" href="#mckay" id="citation-reference-2"&gt;[McKay]&lt;/a&gt;. Mckay’s tests suggested that this pump’s
efficiency was comparable to that of the commercially available Xylem and Money
Maker treadle pumps. Detailed efficiency data for these treadle pumps are not
available and thus an accurate comparison could not be made until now.&lt;/p&gt;
&lt;p&gt;For our experiment, we gathered efficiency data from the Xylem and Money Maker
treadle pumps and compared them to McKay’s data on the prototype Buffalo pump.
By comparing the efficiency of the Buffalo pump to the commercially available
Xylem and Money Maker pumps, we can evaluate the prototype’s potential for
success as a low cost tool for small scale irrigation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="methods"&gt;
&lt;h2&gt;Methods&lt;/h2&gt;
&lt;p&gt;McKay had conducted an efficiency test with the centrifugal pump so our goal
was to conduct a similar test with our treadle pumps in order to produce data
that could be compared. We conducted fifteen tests, with three replicates at
each pressure head between 1 and 5 meters. We pumped 20 liters of water for
each test. We measured time using a photoresistor that was covered and
uncovered (on/off) to record the beginning and end of each test. The DAQ
apparatus including photoresistor circuit, sensor wires, and LabJack is shown
in Figure 2 below.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="DAQ Setup." src="https://objects-us-east-1.dream.io/mechmotum/daq-setup.png" style="width: 50%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 2. The LabJack was kept dry and out of danger behind the treadle pump.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Force sensors were designed using steel plates and two 200 kg rated load cells.
The load cells were mounted between steel plates and then mounted on the
treadle pump lever arms with U-bolts. We calibrated the force sensor using
Olympic weights and a balance scale for reference. The power meter apparatus
consisting of the force sensors and angular rate gyro are shown below in Figure
3.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Treadle Pump Setup." src="https://objects-us-east-1.dream.io/mechmotum/treadle-pump-setup.jpg" style="width: 50%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 3. The Xylem treadle pump with force sensor and angular rate gyro attached&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;We measure force and angular rate using the force sensors and the angular rate
gyro respectively. Using our force measurements, we were able to calculate
torque using the equation below:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\tau = F \times r
\end{equation*}
&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(F\)&lt;/span&gt; is the force in Newtons applied to the lever arm perpendicular
to the arm. The radius &lt;span class="math"&gt;\(r\)&lt;/span&gt; is the distance from the point of applied
force to the lever arm’s center of rotation. Using torque and angular rate
measurements from the angular rate gyro, power in watts is calculated using the
equation below:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
P = \tau \times \omega
\end{equation*}
&lt;/div&gt;
&lt;p&gt;where torque 𝛕 is in Newton-meters and angular velocity 𝛚 is in
radians per second. Time required to fill the 20 liter bucket was measured and
used to calculate flow rate. Hydraulic power could then be calculated using the
equation:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\textrm{Hydraulic Power} = q \times \rho \times g \times h
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Simplifying for water, where density equals 1 kilogram per liter:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\textrm{Hydraulic Power} = q \times g \times h
\end{equation*}
&lt;/div&gt;
&lt;p&gt;where &lt;span class="math"&gt;\(q\)&lt;/span&gt; is measured in liters per second, &lt;span class="math"&gt;\(g\)&lt;/span&gt; is 9.81 meters per
second squared, and &lt;span class="math"&gt;\(h\)&lt;/span&gt; is vertical pressure head measured in meters.
Efficiency can be calculated using the equation below:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\eta = \frac{\textrm{Hydraulic Power}} {\textrm{Input Power}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Hazen efficiency is determined by calculating the friction head loss using the
Hazen-Williams equation:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\textrm{Frictional Head Loss} =
  \frac{\textrm{Pipe Length} \times 10.67 \times (\textrm{flow rate})^{1.852}}
       {(\textrm{Hazen Roughness})^{1.852} \times d^{4.8704}}
\end{equation*}
&lt;/div&gt;
&lt;p&gt;Hydraulic power is adjusted using this estimated friction head. A Hazen
efficiency can then determined.&lt;/p&gt;
&lt;p&gt;Each test began with one person priming the pump in order to achieve consistent
water flow. The collector would deliver the pumped water into an overflow
bucket until the experiment began. At the start of the experiment the treadler
would remove a piece of paper covering the photoresistor. Simultaneously, the
collector would transfer the outlet hose to the 20 L metered collection bucket.
During the data collection, the treadler would attempt to maintain an average
of 100 Watts. This was done by feel only and therefore resulted in some
deviation from the target power. The experiment ended when the collector
signaled to the treadler that 20 L was reached, at which point the
photoresistor was covered and the data collection complete. The data was
collected via a MATLAB program and saved after each trial. 15 trials were
completed: three at each meter interval between 1 and 5 meters.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="results"&gt;
&lt;h2&gt;Results&lt;/h2&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="1m Trials." src="https://objects-us-east-1.dream.io/mechmotum/1m-trials.jpg" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 4&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="2m Trials." src="https://objects-us-east-1.dream.io/mechmotum/2m-trials.jpg" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 5&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="3m Trials." src="https://objects-us-east-1.dream.io/mechmotum/3m-trials.jpg" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 6&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="4m Trials." src="https://objects-us-east-1.dream.io/mechmotum/4m-trials.jpg" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 7&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="5m Trials." src="https://objects-us-east-1.dream.io/mechmotum/5m-trials.jpg" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 8&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The figures 4-8 above show the calculated efficiencies for each pump at
different pressure heads across all trials. The average efficiencies are
graphed in figure 9 below.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Average Efficiency." src="https://objects-us-east-1.dream.io/mechmotum/average-efficiency.jpg" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 9&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Figure 9 shows the efficiency trends across different pressure heads for each
pump. The average efficiency was found by finding the mean across the three
trial tests at each pressure head. The effect that the variation in power may
have had on efficiency was assumed to be negligible. The trendlines and
corresponding equations are shown.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="discussion"&gt;
&lt;h2&gt;Discussion&lt;/h2&gt;
&lt;p&gt;There is a variation in average power within each testing group that must be
acknowledged. Because the average power for each testing group was not held
constant, we must consider the relationship between power and efficiency. When
the trendlines for each testing group are observed, our data does not suggest a
strong relationship between average power and efficiency within a given
pressure head. More data points and a dedicated testing procedure would help
validate this claim, but the observed results are enough to make the assumption
that the effect of any hypothetical correlation is negligible given the range
over which average power varied during our tests. Therefore, the average
efficiencies can be compared between pumps where pressure head is held constant
despite fluctuating average power measurements across trials.&lt;/p&gt;
&lt;p&gt;Figure 9 shows the average efficiencies for each pump at various pressure
heads. The centrifugal Buffalo pump has a negatively sloped trendline whereas
the treadle pumps have positively sloped trendlines when observed between our
range of pressure heads. The Xylem pump surpasses the efficiency of the Buffalo
pump around 4.5 meters pressure head. The Money Maker pump can be predicted to
surpass the efficiency of the Buffalo pump at around 5.5 meters pressure head.
The Xylem and Money Maker pumps share a similar relationship between increased
pressure head and increased efficiency. There is a difference in slope between
the two trendlines of 0.54. Due to shared mechanical properties, all
treadle-type pumps most likely produce similarly sloped trendlines. The
centrifugal Buffalo pump is a completely different design, and thus its
efficiency can be predicted along a completely different trendline.&lt;/p&gt;
&lt;p&gt;The Buffalo pump is determined to be 21% (𝛔 = 6.7%) more efficient at 1
meter pressure head than the Xylem pump, and 32% (𝛔 = 4.9%) more
efficient at the same head when compared to the Money Maker. At 2 meters
pressure head, the Buffalo pump was 17.0% (𝛔 = 2.9%) and 24.7% (𝛔 =
2.4%) more efficient than the Xylem and Money Maker respectively. At 3 meters
head, it was 16.3% (𝛔 = 3.8%) and 26% (𝛔 = 4.1%) more efficient
respectively. At 4 meters, the differences decreased to 2.2% (𝛔 = 4.6%)
and 9.7% (𝛔 = 4.6%). At 5 meters the Xylem pump was 6.8% (𝛔 = 4.9%)
more efficient than the Buffalo pump and the Money Maker was only 2% (𝛔 =
3.7%) less efficient than the Buffalo.&lt;/p&gt;
&lt;p&gt;Until the correlation between power and efficiency can be determined, these
conclusions include an error assumed to be negligible. It is within the best
interest of further research to try and describe this correlation, which may
appear something like this:&lt;/p&gt;
&lt;div class="math"&gt;
\begin{equation*}
\textrm{Efficiency} = C \times \textrm{Power} + B
\end{equation*}
&lt;/div&gt;
&lt;p&gt;For low C values (&amp;lt;&amp;lt;1), our assumption can be considered valid. Our current
assumption is that C=0, where efficiency is not a function of power. It would
also be beneficial to direct further research at determining the range of
pressure heads most frequently encountered in real world irrigation situations.
This information will be critical in determining which human powered water pump
is the most efficient for its given application.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Our research finds that the Buffalo pump is more efficient than the Xylem
treadle pump up to 4.5 meters pressure head, and the Money Maker up to 5.5
meters pressure head. The efficiency advantage of one type of pump over another
will depend largely on pressure head. Figure 9 shows the efficiency trends
between two treadle style pumps and a centrifugal-type water pump.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/p&gt;
&lt;table class="docutils citation" frame="void" id="polak" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#citation-reference-1"&gt;[Polak]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;P. Polak, &amp;quot;How IDE Installed 1.5 Million Treadle Pumps in
Bangladesh by Activating the Private Secotr: The Practical Steps,&amp;quot;
International Development Enterprises (IDE), 2000.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="mckay" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#citation-reference-2"&gt;[McKay]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;A. Mckay. (2018), &amp;quot;The Water Buffalo: Design of a Portable Bicycle
Powered Irrigation Pump for Small-Scale African Farmers&amp;quot; UC Davis, Davis,
California&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="research"/><category term="efficiency"/><category term="treadle pump"/><category term="engineering"/><category term="biomechanics"/><category term="appropriate&#10;technology"/></entry><entry><title>Design of a PID Controller for Controlling The Speed of an Instrumented Ebike</title><link href="https://mechmotum.github.io/blog/ebike-controller-design.html" rel="alternate"/><published>2018-12-15T00:00:00-08:00</published><updated>2018-12-15T00:00:00-08:00</updated><author><name>Trevor Metz</name></author><id>tag:mechmotum.github.io,2018-12-15:/blog/ebike-controller-design.html</id><summary type="html">&lt;p class="first last"&gt;Blog post on designing a speed controller for an instrumented ebike.&lt;/p&gt;
</summary><content type="html">&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;The goal of this project is to design and implement a control system for an
instrumented ebike used in bicycle handling experimentation. To achieve this, a
basic unity feedback control architecture (Figure 1) is employed.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Control Architecture." src="https://objects-us-east-1.dream.io/mechmotum/bike-speed-control-01.jpg" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 1. Control architecture where e is the error between the actual
speed v of the ebike and the desired speed, vd, and V is the DC input
voltage to the ebike plant model. Gc and Gp represent the controller and
plant model respectively.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The goal of the controller is to track a setpoint speed, within +/- 0.10 m/s,
set by the rider.  To achieve this, a PID controller was tuned using MATLAB’s
Control System Toolbox. The ebike plant model was derived using first
principles and grey box system identification.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="modeling-the-ebike-from-first-principles"&gt;
&lt;h2&gt;Modeling the eBike From First Principles&lt;/h2&gt;
&lt;p&gt;The dynamics of the ebike powertrain and the vehicle itself can be modeled from
first principles. The powertrain of the ebike consists of a standard ebike
conversion kit motor controller and a brushless 3 phase direct drive induction
motor mounted to the rear hub of the bike. A simple diagram of the ebike
drivetrain is shown below in Figure 2.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Ebike Drivetrain Diagram." src="https://objects-us-east-1.dream.io/mechmotum/bike-speed-control-02.jpg" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 2. Diagram of the drivetrain circuit and dynamics.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;In Figure 2, the induction motor is approximated by a model of a DC motor
circuit with resistance &lt;span class="math"&gt;\(R\)&lt;/span&gt;, inductance &lt;span class="math"&gt;\(L\)&lt;/span&gt; and back emf
&lt;span class="math"&gt;\(V_b\)&lt;/span&gt;. The torques &lt;span class="math"&gt;\(T_m\)&lt;/span&gt; and &lt;span class="math"&gt;\(T_p\)&lt;/span&gt; acting on the motor shaft
correspond to motor torque and wheel propulsion torque respectively. The
rotational dynamics of the drivetrain are defined by Euler’s rotation equation.&lt;/p&gt;
&lt;p&gt;A simple equation of motion for the bicycle, modeled as a point mass, is
derived using Newton’s 2nd Law of Motion in the horizontal direction &lt;a class="citation-reference" href="#wilson" id="citation-reference-1"&gt;[Wilson]&lt;/a&gt;.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Free Body Diagram of Bicycle." src="https://objects-us-east-1.dream.io/mechmotum/bike-speed-control-03.jpg" style="width: 20%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 3. Free body diagram of the bicycle modeled as a point mass. Fa, Fr
and Fp are the aerodynamic drag, rolling resistance and propulsive forces
respectively.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Together, the vehicle and drivetrain dynamics of the ebike can be shown in a
state space representation with state variables &lt;span class="math"&gt;\(i(t)\)&lt;/span&gt; and &lt;span class="math"&gt;\(x(t)\)&lt;/span&gt;
as seen below.&lt;/p&gt;
&lt;img alt="State Space Representation of the eBike." class="align-center" src="https://objects-us-east-1.dream.io/mechmotum/bike-speed-control-04.jpg" style="width: 55%;" /&gt;
&lt;p&gt;From the state space representation, a transfer function from input DC voltage
&lt;span class="math"&gt;\(V\)&lt;/span&gt; to output speed &lt;span class="math"&gt;\(v\)&lt;/span&gt; is formed:&lt;/p&gt;
&lt;img alt="Plant Model Transfer Function." class="align-center" src="https://objects-us-east-1.dream.io/mechmotum/bike-speed-control-05.jpg" style="width: 80%;" /&gt;
&lt;p&gt;This plant model is a second order transfer function relating an applied DC
voltage input to the ebike’s motor controller to the output speed of the ebike.
This model represents an approximation of the true plant model of the ebike. To
get a more accurate plant model, a grey box system identification procedure
based on measured time response data from the ebike was used.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="performing-system-identification-from-experimental-data"&gt;
&lt;h2&gt;Performing System Identification From Experimental Data&lt;/h2&gt;
&lt;p&gt;To begin the process of system identification, the values of the ebike
drivetrain model parameters and bicycle drag and tire rolling resistance
coefficients were initialized using reasonable approximations found from
internet searches, previous knowledge of the instrumented ebike &lt;a class="citation-reference" href="#moore" id="citation-reference-2"&gt;[Moore]&lt;/a&gt; and
textbook resources &lt;a class="citation-reference" href="#wilson" id="citation-reference-3"&gt;[Wilson]&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In MATLAB, a nonlinear least-squares solver was used to optimize the constants
in the derived plant model of the ebike to match a speed time response measured
from the instrumented ebike. Figure 4, below, shows the curve fitting result.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Curve Fitting Results." src="https://objects-us-east-1.dream.io/mechmotum/bike-speed-control-06.jpg" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 4. Result of the least-squares curve fitting.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Figure 4 shows that the plant model of ebike was reasonably identified using
the least-squares curve fitting method. The resulting ebike plant model is:&lt;/p&gt;
&lt;img alt="Identified Plant Model." class="align-center" src="https://objects-us-east-1.dream.io/mechmotum/bike-speed-control-07.jpg" style="width: 90%;" /&gt;
&lt;/div&gt;
&lt;div class="section" id="controller-design-in-matlab"&gt;
&lt;h2&gt;Controller Design in MATLAB&lt;/h2&gt;
&lt;p&gt;With the plant model of the ebike identified, a PID controller (kp = 68.5, ki =
106, kd = 1.44) was tuned for zero steady state error and reasonable transient
behavior using MATLAB’s Control System Toolbox.&lt;/p&gt;
&lt;p&gt;The closed loop step response (Figure 5) shows that the controller meets the
design goals with zero steady state error, a settling time of 1.56s, and an
overshoot percentage of 10.45%.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Closed Loop System Step Response." src="https://objects-us-east-1.dream.io/mechmotum/bike-speed-control-08.jpg" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 5. Closed Loop System Step Response.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="evaluation-of-controller-robustness"&gt;
&lt;h2&gt;Evaluation of Controller Robustness&lt;/h2&gt;
&lt;p&gt;MATLAB’s Robust Control Toolbox was used to test the robustness of the closed
loop system with regards to uncertainties in the coefficients of the identified
ebike plant model. The constants in the derived ebike plant model were lumped
together forming the following simplified plant model:&lt;/p&gt;
&lt;img alt="Simplified Plant Model." class="align-center" src="https://objects-us-east-1.dream.io/mechmotum/bike-speed-control-09.jpg" style="width: 90%;" /&gt;
&lt;p&gt;The constants &lt;span class="math"&gt;\(a\)&lt;/span&gt;, &lt;span class="math"&gt;\(b\)&lt;/span&gt;, &lt;span class="math"&gt;\(c\)&lt;/span&gt;, and &lt;span class="math"&gt;\(d\)&lt;/span&gt; in the above
transfer function were defined in MATLAB as real-uncertain parameters with
varying percentage based uncertainties about their nominal values. The nominal
values of each coefficient were taken from the result of the system
identification step of the controller design process.  Figure 6, below, shows
the nominal closed loop and open loop system step response with 20 random
samples of the uncertain plant model defined by the uncertain coefficients.&lt;/p&gt;
&lt;div class="figure align-center"&gt;
&lt;img alt="Uncertain Step Response." src="https://objects-us-east-1.dream.io/mechmotum/bike-speed-control-10.jpg" style="width: 80%;" /&gt;
&lt;p class="caption"&gt;&lt;em&gt;Figure 6. Step response of the nominal closed loop system with 20 random
samples of the uncertain closed loop step response superimposed on the
plot.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Figure 6 shows that the closed loop system is reasonably robust despite
uncertainty in the plant model. Having this robustness in the control system
means that small changes in the dynamics of the ebike will not cause the
controller to have undesirable performance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;A simple PID controller used in a unity feedback control architecture was
designed to reduce the steady state error and improve the transient performance
of the speed time response of an instrumented ebike. Using grey box system
identification, the plant model of the ebike was identified and used in the
controller design. A PID tuner app was used to tune the controller constants to
achieve zero steady state gain and favorable transient behavior. Finally, the
robustness of the controller was tested by simulating uncertainties in the
closed loop system.&lt;/p&gt;
&lt;p&gt;The next step in the project is to take the continuous time PID controller and
implement it digitally on the instrumented ebike. Stay tuned for part two:
Implementing a PID Controller on an Instrumented Ebike.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;table class="docutils citation" frame="void" id="wilson" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[Wilson]&lt;/td&gt;&lt;td&gt;&lt;em&gt;(&lt;a class="fn-backref" href="#citation-reference-1"&gt;1&lt;/a&gt;, &lt;a class="fn-backref" href="#citation-reference-3"&gt;2&lt;/a&gt;)&lt;/em&gt; Wilson, D., Papadopoulos, J. and Whitt, F. (2004). Bicycling science.
Cambridge, Mass.: MIT Press.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils citation" frame="void" id="moore" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#citation-reference-2"&gt;[Moore]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;Moore, J. (2012). Human Control of a Bicycle.
Available at: &lt;a class="reference external" href="http://moorepants.github.io/dissertation/davisbicycle.html"&gt;http://moorepants.github.io/dissertation/davisbicycle.html&lt;/a&gt;
[Accessed 12 Dec. 2018].&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="research"/><category term="controls"/><category term="instrumentation"/><category term="engineering"/><category term="mechatronics"/><category term="bicycle"/></entry></feed>