<!doctype html>
<html lang="en">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>  SymPy CZI Grant Code Generation & Biomechanics Outcomes | Bicycle Laboratorium
</title>
  <link rel="canonical" href="https://mechmotum.github.io/blog/czi-sympy-wrapup.html">


  <link rel="stylesheet" href="https://mechmotum.github.io/theme/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://mechmotum.github.io/theme/css/fontawesome.min.css">
  <link rel="stylesheet" href="https://mechmotum.github.io/theme/css/pygments/default.min.css">
  <link rel="stylesheet" href="https://mechmotum.github.io/theme/css/theme.css">
  <link rel="stylesheet" href="https://mechmotum.github.io/theme/css/origtheme.css">

  <link rel="alternate" type="application/atom+xml" title="Full Atom Feed"
        href="https://mechmotum.github.io/feeds/all.atom.xml">
  <link rel="alternate" type="application/atom+xml" title="Categories Atom Feed"
        href="https://mechmotum.github.io/feeds/research.atom.xml">  
  <meta name="description" content="Summary of the work performed under the Chan-Zuckerberg Foundation Open Source Software for Science Cycle 4 grant awarded to Sympy and performed by Delft University of Technology. We developed new biomechanics capabilities in SymPy and improved code generation performance for large mathematical expressions.">


</head>

<body>
  <header class="header">
    <div class="container">
<div class="row">
    <div class="col-sm-4">
      <a href="https://mechmotum.github.io/">
        <img class="site-image img-fluid rounded" src=https://objects-us-east-1.dream.io/mechmotum/bear-bicycle-transparent-480x480.png alt="Bicycle Laboratorium">
      </a>
    </div>
  <div class="col-sm-8">
    <img src=https://objects-us-east-1.dream.io/mechmotum/tu-delft-logo-233x100.png height=100px>
    <h1 class="title"><a href="https://mechmotum.github.io/">Bicycle Laboratorium</a></h1>
      <p class="text-muted">E pur si muove</p>
      <ul class="list-inline">
            <li class="list-inline-item"><a href="https://mechmotum.github.io/">About</a></li>
            <li class="list-inline-item"><a href="https://mechmotum.github.io/members.html">Members</a></li>
            <li class="list-inline-item"><a href="https://mechmotum.github.io/research.html">Research</a></li>
            <li class="list-inline-item"><a href="https://mechmotum.github.io/products.html">Products</a></li>
            <li class="list-inline-item"><a href="https://mechmotum.github.io/jobs.html">Jobs</a></li>
            <li class="list-inline-item"><a href="https://mechmotum.github.io/guide.html">Guide</a></li>
            <li class="list-inline-item"><a href="https://mechmotum.github.io/contact.html">Contact</a></li>
          <li class="list-inline-item"><a href="/blog/">Blog</a></li>
      </ul>
  </div>
</div>    </div>
  </header>

  <div class="main">
    <div class="container">
      <h1>  SymPy CZI Grant Code Generation &amp; Biomechanics Outcomes
</h1>
      <hr>
  <article class="article">
    <header>
      <ul class="list-inline">
        <li class="list-inline-item text-muted" title="2023-10-27T00:00:00-07:00">
          <i class="fas fa-clock"></i>
          Fri 27 October 2023
        </li>
        <li class="list-inline-item">
          <i class="fas fa-folder-open"></i>
          <a href="https://mechmotum.github.io/category/research.html">research</a>
        </li>
          <li class="list-inline-item">
            <i class="fas fa-user"></i>
              <a href="https://mechmotum.github.io/author/jason-k-moore.html">Jason K. Moore</a>          </li>
          <li class="list-inline-item">
            <i class="fas fa-tag"></i>
              <a href="https://mechmotum.github.io/tag/sympy.html">#sympy</a>,               <a href="https://mechmotum.github.io/tag/czi.html">#czi</a>,               <a href="https://mechmotum.github.io/tag/biomechanics.html">#biomechanics</a>,               <a href="https://mechmotum.github.io/tag/multibody-dynamics.html">#multibody dynamics</a>,               <a href="https://mechmotum.github.io/tag/open-source-software.html">#open source software</a>,               <a href="https://mechmotum.github.io/tag/muscles.html">#muscles</a>,               <a href="https://mechmotum.github.io/tag/optimal-control.html">#optimal control</a>,               <a href="https://mechmotum.github.io/tag/bicycle.html">#bicycle</a>,               <a href="https://mechmotum.github.io/tag/skateboard.html">#skateboard</a>,               <a href="https://mechmotum.github.io/tag/code-generation.html">#code generation</a>          </li>
      </ul>
    </header>


    <div class="content">
      <table border="1" class="borderless docutils align-center" style="width: 60%">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><img alt="sympy-logo" src="https://docs.sympy.org/dev/_images/sympy-500px.png" style="height: 200px;" /></td>
<td><img alt="czi-logo" src="https://objects-us-east-1.dream.io/mechmotum/czi-logo.png" style="height: 200px;" /></td>
</tr>
</tbody>
</table>
<div class="contents floatcon local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="toc-entry-1">Introduction</a></li>
<li><a class="reference internal" href="#general-improvements-to-sympy-mechanics" id="toc-entry-2">General Improvements to SymPy Mechanics</a><ul>
<li><a class="reference internal" href="#joints-package" id="toc-entry-3">Joints Package</a></li>
<li><a class="reference internal" href="#symbolic-solutions-to-linear-equations" id="toc-entry-4">Symbolic Solutions to Linear Equations</a><ul>
<li><a class="reference internal" href="#choice-of-generalized-coordinates-and-speeds" id="toc-entry-5">1. Choice of Generalized Coordinates and Speeds</a></li>
<li><a class="reference internal" href="#alternative-symbolic-solvers" id="toc-entry-6">2. Alternative Symbolic Solvers</a></li>
<li><a class="reference internal" href="#division-free-linear-solves" id="toc-entry-7">3. Division-free Linear Solves</a></li>
<li><a class="reference internal" href="#delayed-numerical-solves" id="toc-entry-8">4. Delayed Numerical Solves</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inertia-loads-actuators" id="toc-entry-9">Inertia, Loads, Actuators</a></li>
<li><a class="reference internal" href="#system-class" id="toc-entry-10">System Class</a></li>
</ul>
</li>
<li><a class="reference internal" href="#introducing-sympy-biomechanics" id="toc-entry-11">Introducing SymPy Biomechanics</a></li>
<li><a class="reference internal" href="#code-generation-improvements" id="toc-entry-12">Code Generation Improvements</a></li>
<li><a class="reference internal" href="#modeling-and-optimal-control-uses" id="toc-entry-13">Modeling and Optimal Control Uses</a><ul>
<li><a class="reference internal" href="#optimal-skateboard-ollie" id="toc-entry-14">Optimal Skateboard Ollie</a></li>
<li><a class="reference internal" href="#brim" id="toc-entry-15">BRiM</a></li>
<li><a class="reference internal" href="#optimal-bicycle-rider-trajectories" id="toc-entry-16">Optimal Bicycle-Rider Trajectories</a></li>
</ul>
</li>
<li><a class="reference internal" href="#conclusion" id="toc-entry-17">Conclusion</a><ul>
<li><a class="reference internal" href="#lessons-learned" id="toc-entry-18">Lessons Learned</a></li>
<li><a class="reference internal" href="#future-plans" id="toc-entry-19">Future Plans</a></li>
</ul>
</li>
<li><a class="reference internal" href="#work-summary" id="toc-entry-20">Work Summary</a></li>
<li><a class="reference internal" href="#references" id="toc-entry-21">References</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#toc-entry-1">Introduction</a></h2>
<p>We were awarded a <a class="reference external" href="https://doi.org/10.6084/m9.figshare.16590053.v1">two year grant</a> from CZI to improve <a class="reference external" href="https://www.sympy.org">SymPy</a>. There were
three work packages led by each of the three co-principal investigators:</p>
<ul class="simple">
<li>Improve SymPy's Documentation (Aaron Meuer, Quantsight)</li>
<li>Improve SymPy's Performance (Oscar Benjamin, University of Bristol)</li>
<li>Improve SymPy's Code Generation for Biomechanical Modeling (Jason K. Moore,
Delft University of Technology)</li>
</ul>
<p>We were in charge of the last work package and hired Dr. Sam Brockie to work on
the project as a postdoctoral researcher. Jan Heinen and Timo Stienstra worked
on the project through their TU Delft MSc degrees under the supervision of Sam
and Jason.</p>
<p>Our overarching goal is to use SymPy to generate symbolic dynamical models of
biomechanical systems, i.e. multibody systems actuated by muscles. This
involves formulating the Newton-Euler equations of motion, possibly with
additional kinematic constraints, and the differential equations that describe
the relationship between neurological excitation and generated muscles forces.</p>
<p>We selected a complex human-machine system as a benchmark problem to motivate
our work: the bicycle and its rider. The nonlinear and linear equations of
motion of a riderless bicycle have traditionally been a very challenging system
to derive correctly in full symbolic form (see <a class="citation-reference" href="#basumandal2007" id="citation-reference-1">[BasuMandal2007]</a> and
<a class="citation-reference" href="#meijaard2007" id="citation-reference-2">[Meijaard2007]</a> for background). Including a model of a human rider with
muscle-driven joints increases the model's complexity even further. This model
is made up of millions of arithmetic and transcendental operations, making it a
challenging system to differentiate and evaluate efficiently. We want SymPy to
be able to handle models of this complexity with ease. To test SymPy's ability
to correctly derive, differentiate, and evaluate the bicycle-rider's governing
equations, we choose to formulate and solve a <a class="reference external" href="https://en.wikipedia.org/wiki/Trajectory_optimization">trajectory optimization</a>
problem via <a class="reference external" href="https://en.wikipedia.org/wiki/Collocation_method">direct collocation</a>. We knew that this bicycle-rider optimal
control problem would test SymPy's limits, forcing us to make significant
improvements to SymPy's code generation features. To do this, we worked on
numerous areas in SymPy and downstream packages to reach this goal.</p>
</div>
<div class="section" id="general-improvements-to-sympy-mechanics">
<h2><a class="toc-backref" href="#toc-entry-2">General Improvements to SymPy Mechanics</a></h2>
<div class="section" id="joints-package">
<h3><a class="toc-backref" href="#toc-entry-3">Joints Package</a></h3>
<p>Timo Stienstra began working on this project through a 2022 Google Summer of
Code internship where he improved the SymPy Mechanics <a class="reference external" href="https://docs.sympy.org/latest/modules/physics/mechanics/joints.html">joints modules</a> with
documentation improvements, by reworking the fundamental definition of a joint,
and adding new cylindrical, planar, and spherical joints. These were key early
updates to enable the joints package's use in constructing a bicycle-rider
model. See the details of Timo's work in his <a class="reference external" href="https://github.com/sympy/sympy/wiki/GSoC-2022-Report-Timo-Stienstra-:-Enhancing-the-Joints-Framework">GSoC Report</a>. This project led
Timo to do a TU Delft Biomechanical Design MSc project on bicycle-rider
modeling using SymPy.</p>
<table border="1" class="borderless docutils align-center" style="width: 100%">
<caption>Figure 1: Old and new joint types with new explanatory figures
can be found in the SymPy documentation.</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><img alt="joint1" src="https://objects-us-east-1.dream.io/mechmotum/PinJoint.png" style="height: 180px;" /></td>
<td><img alt="joint2" src="https://objects-us-east-1.dream.io/mechmotum/PrismaticJoint.png" style="height: 180px;" /></td>
</tr>
<tr><td><img alt="joint3" src="https://objects-us-east-1.dream.io/mechmotum/CylindricalJoint.png" style="height: 180px;" /></td>
<td><img alt="joint4" src="https://objects-us-east-1.dream.io/mechmotum/PlanarJoint.png" style="height: 180px;" /></td>
</tr>
<tr><td><img alt="joint5" src="https://objects-us-east-1.dream.io/mechmotum/SphericalJoint.png" style="height: 180px;" /></td>
<td><img alt="joint6" src="https://objects-us-east-1.dream.io/mechmotum/WeldJoint.png" style="height: 180px;" /></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="symbolic-solutions-to-linear-equations">
<h3><a class="toc-backref" href="#toc-entry-4">Symbolic Solutions to Linear Equations</a></h3>
<p>Kane's Method relies on solving three sets of linear equations:</p>
<ol class="arabic simple">
<li>putting the kinematical differential equations in explicit form
<span class="math">\(\dot{\mathbf{q}} = \mathbf{M}_k^{-1}\left(\mathbf{u} +
\mathbf{f}_k\right)\)</span></li>
<li>putting the dynamical differential equations in explicit form
<span class="math">\(\dot{\mathbf{u}} = \mathbf{M}_d^{-1}\mathbf{f}_d\)</span></li>
<li>solving the dependent generalized speeds in terms of the independent
generalized speeds
<span class="math">\(\mathbf{u}_r = \mathbf{A}_r^{-1}(\mathbf{A}_s\mathbf{u}_s + \mathbf{f}_{rs})\)</span></li>
</ol>
<p>If these equations are symbolic, it is mostly impossible to determine if an
entry is zero when pivoting in <a class="reference external" href="https://en.wikipedia.org/wiki/Gaussian_elimination">Gaussian elimination</a> making the solutions
susceptible to divide-by-zero operations for ranges of numerical values for the
variables involved.</p>
<p>There are four ways, it seems, to deal with this:</p>
<ol class="arabic simple">
<li>select the generalized coordinates, generalized speeds, and constants such
that divide-by-zero cannot occur for the numerical values of interest</li>
<li>select symbolic Gaussian elimination algorithms that do not put the
solutions in a form that has divide-by-zero for the numerical values of
interest</li>
<li>use a zero-division free linear solve algorithm</li>
<li>defer the linear solves to numerical algorithms</li>
</ol>
<div class="section" id="choice-of-generalized-coordinates-and-speeds">
<h4><a class="toc-backref" href="#toc-entry-5">1. Choice of Generalized Coordinates and Speeds</a></h4>
<p>The choice of generalized coordinates and generalized speeds changes which
entries in the linear coefficient matrix can be zero for specific values of the
coordinates and speeds. It may be possible to avoid divide-by-zero with careful
selection of the variables when defining the kinematics of the specific
problem. But this will require unique solutions for every model.</p>
</div>
<div class="section" id="alternative-symbolic-solvers">
<h4><a class="toc-backref" href="#toc-entry-6">2. Alternative Symbolic Solvers</a></h4>
<p>In 2014, we switched to using <tt class="docutils literal">LUsolve()</tt> for all of the linear solves in
SymPy Mechanics in <a class="reference external" href="https://github.com/sympy/sympy/pull/7581">PR 7581</a>, which resulted in an unnoticed regression of
divide-by-zero issues for complex problems. This change broke the crucial
<a class="reference external" href="https://github.com/sympy/sympy/blob/master/sympy/physics/mechanics/tests/test_kane3.py">test_kane3.py</a> as well as the corresponding <a class="reference external" href="https://docs.sympy.org/latest/modules/physics/mechanics/examples/bicycle_example.html">documentation page</a>
that solved the linear Carvallo-Whipple bicycle model to a machine precision
match against published benchmarks. This bug has hounded us for 9 years (see
<a class="reference external" href="https://github.com/pydy/pydy/pull/122">https://github.com/pydy/pydy/pull/122</a> and
<a class="reference external" href="https://github.com/sympy/sympy/issues/9641">https://github.com/sympy/sympy/issues/9641</a>).</p>
<p>Timo discovered the fundamental divide-by-zero issue after <a class="reference external" href="https://github.com/sympy/sympy/issues/24780">much sleuthing and
discussion</a>. He then introduced a new linear solver that uses <a class="reference external" href="https://en.wikipedia.org/wiki/Cramer%27s_rule">Cramer's
rule</a>, which can eliminate divide-by-zero operations in many cases. We then
added support to <tt class="docutils literal">KanesMethod()</tt> and <tt class="docutils literal">Linearizer()</tt> for using linear
solvers other than <tt class="docutils literal">LUSolve()</tt> including the new Cramer's rule-based solver
as an option. With this we closed the <a class="reference external" href="https://github.com/sympy/sympy/issues/9641">9 year old bug</a> and allowed our base
bicycle model to build both in non-linear and linear forms. The new Cramer
solve method for matrices was introduced in
<a class="reference external" href="https://github.com/sympy/sympy/pull/25179">https://github.com/sympy/sympy/pull/25179</a>.</p>
</div>
<div class="section" id="division-free-linear-solves">
<h4><a class="toc-backref" href="#toc-entry-7">3. Division-free Linear Solves</a></h4>
<p>There are division-free algorithms that can be used in solving linear systems,
but the complexity of the resulting equations grows considerably, for example
see <a class="citation-reference" href="#bird2011" id="citation-reference-3">[Bird2011]</a>.</p>
</div>
<div class="section" id="delayed-numerical-solves">
<h4><a class="toc-backref" href="#toc-entry-8">4. Delayed Numerical Solves</a></h4>
<p>It would be helpful if we could delay linear solves to the numerical
evaluation, so that pivot points can managed by <a class="reference external" href="https://www.netlib.org/lapack/">LAPACK</a>'s solvers. To do so, we
would need to be able to use the results of a linear solve like any other
symbol without symbolically evaluating the linear solve operation. The
following SymPy code almost works as desired:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">MatrixSymbol</span><span class="p">,</span> <span class="n">Inverse</span><span class="p">,</span> <span class="n">lambdify</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">MatrixSymbol</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Inverse</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">@</span> <span class="n">b</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">eval_result</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
<p>The above works but the inverse and matrix multiplication are evaluated
symbolically when called, as can be seen in the generated function:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">eval_result</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Source code:</span>

<span class="go">def _lambdifygenerated(A, b):</span>
<span class="go">    return A[0, 0]*b[1, 0]/(A[0, 0]*A[1, 1] - A[0, 1]*A[1, 0]) - A[0, 1]*b[1, 0]/(A[0, 0]*A[1, 1] - A[0, 1]*A[1, 0]) - A[1, 0]*b[0, 0]/(A[0, 0]*A[1, 1] - A[0, 1]*A[1, 0]) + A[1, 1]*b[0, 0]/(A[0, 0]*A[1, 1] - A[0, 1]*A[1, 0])</span>
<span class="gp">...</span>
</pre></div>
<p>Instead, we'd like <tt class="docutils literal">lambdify()</tt> to generate code that looks more like:</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">eval_result</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
   <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
<p>which allows NumPy (or actually LAPACK) to use the appropriate algorithm given
the numerical values used for A and b. The expression <tt class="docutils literal">Inverse(A) &#64; b</tt> would
need to remain unevaluated for code generation to properly handle it. In SymPy,
there is a <tt class="docutils literal">MatrixSolve()</tt> code generation node that acts as an unevaluated
linear equation solver and works as desired with <tt class="docutils literal">lambdify()</tt>:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy.codegen.matrix_nodes</span> <span class="kn">import</span> <span class="n">MatrixSolve</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">MatrixSolve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_x</span> <span class="o">=</span> <span class="n">lambdify</span><span class="p">((</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">help</span><span class="p">(</span><span class="n">eval_x</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">Source code:</span>

<span class="go">def _lambdifygenerated(A, b):</span>
<span class="go">    return solve(A, b)</span>
<span class="gp">...</span>
</pre></div>
<p>But <tt class="docutils literal">MatrixSolve()</tt> does not support indexing the solution:</p>
<div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">---------------------------------------------------------------------------</span>
<span class="go">NotImplementedError                       Traceback (most recent call last)</span>
<span class="go">Cell In[8], line 1</span>
<span class="go">----&gt; 1 result = x[0, 0] + x[1, 0]</span>

<span class="go">File ~/miniconda/lib/python3.9/site-packages/sympy/matrices/expressions/matexpr.py:300, in MatrixExpr.__getitem__(self, key)</span>
<span class="go">    298 i, j = _sympify(i), _sympify(j)</span>
<span class="go">    299 if self.valid_index(i, j) != False:</span>
<span class="go">--&gt; 300     return self._entry(i, j)</span>
<span class="go">    301 else:</span>
<span class="go">    302     raise IndexError(&quot;Invalid indices (%s, %s)&quot; % (i, j))</span>

<span class="go">File ~/miniconda/lib/python3.9/site-packages/sympy/matrices/expressions/matexpr.py:243, in MatrixExpr._entry(self, i, j, **kwargs)</span>
<span class="go">    242 def _entry(self, i, j, **kwargs):</span>
<span class="go">--&gt; 243     raise NotImplementedError(</span>
<span class="go">    244         &quot;Indexing not implemented for %s&quot; % self.__class__.__name__)</span>

<span class="go">NotImplementedError: Indexing not implemented for MatrixSolve</span>
</pre></div>
<p>Timo has an open pull request that uses <tt class="docutils literal">BlockMatrix()</tt> with
<tt class="docutils literal">MatrixSolve()</tt> for the solution of dependent speeds in <tt class="docutils literal">KanesMethod</tt>, that
can at least give this delayed solve with <tt class="docutils literal"><span class="pre">lambdify(modules='NumPy')</span></tt>, see
<a class="reference external" href="https://github.com/sympy/sympy/pull/24916">https://github.com/sympy/sympy/pull/24916</a>.</p>
</div>
</div>
<div class="section" id="inertia-loads-actuators">
<h3><a class="toc-backref" href="#toc-entry-9">Inertia, Loads, Actuators</a></h3>
<p>We introduced three new helper classes to extend the functionality of inertia
and loads beyond that of simply dyadics and vectors: <tt class="docutils literal">Inertia()</tt>,
<tt class="docutils literal">Force()</tt>, and <tt class="docutils literal">Torque()</tt>. The inertia object lets you associate a dyadic
with a point, to completely define inertia for a rigid body, particle, or
collection of them. Force and Torque are named tuples that associate a vector
and point and a vector and a frame, respectively.</p>
<p>We have introduced an <a class="reference external" href="https://docs.sympy.org/dev/modules/physics/mechanics/api/actuator.html">actuator</a> module that has classes that describe the
equal and opposite pair of forces or torques and force actuators can operate
along a pathway, generating resultant forces on points that lie along the
pathway. We included a linear spring and damper as example actuators. The
pathways are located in the new <a class="reference external" href="https://docs.sympy.org/dev/modules/physics/mechanics/api/pathway.html">pathway</a> module.</p>
<p>These new objects provide core building blocks for developing musculotendon
actuators and managing a full multibody system.</p>
</div>
<div class="section" id="system-class">
<h3><a class="toc-backref" href="#toc-entry-10">System Class</a></h3>
<p>Timo developed a new <a class="reference external" href="https://docs.sympy.org/dev/modules/physics/mechanics/api/system.html#sympy.physics.mechanics._system.System">System()</a> class that manages all the information about a
multibody system (coordinates, joints, bodies, constraints, etc.) and can
generate the equations of motion from the high level description of the system
without having to manually write the mathematical equations. This approach
generally reduces the amount of code needed to generate the equations for
complex systems. See the <a class="reference external" href="https://docs.sympy.org/dev/modules/physics/mechanics/examples/four_bar_linkage_example.html">Four-bar Linkage</a> example to get an idea of how it
works.</p>
</div>
</div>
<div class="section" id="introducing-sympy-biomechanics">
<h2><a class="toc-backref" href="#toc-entry-11">Introducing SymPy Biomechanics</a></h2>
<p>We have developed a substantial new sub-package, <a class="reference external" href="https://docs.sympy.org/dev/modules/physics/biomechanics/index.html">sympy.physics.biomechanics</a>,
that enables including musculotendon force actuators in multibody dynamics
models created with <tt class="docutils literal">sympy.physics.mechanics</tt>. <tt class="docutils literal">biomechanics</tt> contains
these primary modules:</p>
<ul class="simple">
<li><tt class="docutils literal">curve.py</tt>: contains classes that represent mathematical functional
relationships between the time-varying muscle-tendon length, velocity, and
force</li>
<li><tt class="docutils literal">activation.py</tt>: contains classes that manage the excitation to activation
dynamics</li>
<li><tt class="docutils literal">musculotendon.py</tt>: contains classes that represent complete musculotendon
models with one reference implementation from <a class="citation-reference" href="#degroote2016" id="citation-reference-4">[DeGroote2016]</a></li>
</ul>
<p>A full explanation of this package and the modules can be found in the new
<a class="reference external" href="https://docs.sympy.org/dev/tutorials/biomechanics/biomechanics.html">Introduction to Biomechanical Modeling</a>
tutorial. We demonstrate the package on a non-trivial biomechanical system in
the new <a class="reference external" href="https://docs.sympy.org/dev/tutorials/biomechanics/biomechanical-model-example.html">Biomechanical Model Example</a>
tutorial.</p>
<table border="1" class="borderless docutils align-center" style="width: 100%">
<caption>Figure 2: On the left, the muscle(red)-driven arm (black C and
D) pushing and pulling a lever taken from the new tutorial. On the right,
are simulation results from the model with a commanded muscle excitation.</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><img alt="biomechanics-steerer" src="https://objects-us-east-1.dream.io/mechmotum/biomechanics-steerer.png" style="width: 100%;" /></td>
<td><img alt="biomechanics-steerer-results" src="https://docs.sympy.org/dev/_images/biomechanical-model-example-38.png" style="width: 100%;" /></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="code-generation-improvements">
<h2><a class="toc-backref" href="#toc-entry-12">Code Generation Improvements</a></h2>
<p>The function <a class="reference external" href="https://docs.sympy.org/latest/modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify">lambdify()</a> is the primary interface for converting SymPy
expressions into NumPy-powered Python functions for numerical evaluation.
<tt class="docutils literal">lambdify()</tt> relies on SymPy's code generation to generate the appropriate
Python code. <tt class="docutils literal">lambdify()</tt> has not been able to handle large mechanics models
in the past. We proposed adding common sub-expression elimination (CSE) support
to help with that.  Support for the <a class="reference external" href="https://docs.sympy.org/latest/modules/simplify/simplify.html#sympy.simplify.cse_main.cse">cse()</a> function was added to
<tt class="docutils literal">lambdify()</tt> just before we started the CZI work in
<a class="reference external" href="https://github.com/sympy/sympy/pull/21546">https://github.com/sympy/sympy/pull/21546</a>. Here is an example that demonstrates
some of the speed improvements:</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">count_ops</span><span class="p">,</span> <span class="n">lambdify</span>
<span class="kn">from</span> <span class="nn">sympy.physics.mechanics</span> <span class="kn">import</span> <span class="n">find_dynamicsymbols</span><span class="p">,</span> <span class="n">dynamicsymbols</span>
<span class="kn">from</span> <span class="nn">sympy.physics.mechanics.models</span> <span class="kn">import</span> <span class="n">n_link_pendulum_on_cart</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
<p>Generating the equations of motion with <tt class="docutils literal">KanesMethod</tt> will be faster for some
models in the next release of SymPy due to <a class="reference external" href="https://github.com/sympy/sympy/pull/24792">Pull Request 24792</a>. This shows the speed in SymPy
1.11.1:</p>
<div class="highlight"><pre><span></span>In [1]: %time kane = n_link_pendulum_on_cart(n=14)
CPU times: user 7.45 s, sys: 3.69 ms, total: 7.46 s
Wall time: 7.47 s
</pre></div>
<p>and the same in the tip of the master branch (1.13.dev0):</p>
<div class="highlight"><pre><span></span>In [1]: %time kane = n_link_pendulum_on_cart(n=14)
CPU times: user 4.85 s, sys: 3.81 ms, total: 4.85 s
Wall time: 4.85 s
</pre></div>
<div class="highlight"><pre><span></span><span class="n">large_expr</span> <span class="o">=</span> <span class="n">kane</span><span class="o">.</span><span class="n">mass_matrix_full</span> <span class="o">@</span> <span class="n">kane</span><span class="o">.</span><span class="n">forcing_full</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">find_dynamicsymbols</span><span class="p">(</span><span class="n">large_expr</span><span class="p">))</span>
<span class="n">p</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">large_expr</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">dynamicsymbols</span><span class="o">.</span><span class="n">_t</span><span class="p">)</span>
<span class="n">x_vals</span><span class="p">,</span> <span class="n">p_vals</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
</pre></div>
<p>These expressions have almost 300 thousand operations:</p>
<div class="highlight"><pre><span></span>In [1]: count_ops(large_expr)
Out[1]: 282836
</pre></div>
<p>In SymPy 1.12, lambdifying large expressions will take at least half the time
as prior versions because there is wasted time printing the full expression to
the docstring. Sam sped up lambdify's code generation by disabling the
docstring generation for large expressions in <a class="reference external" href="https://github.com/sympy/sympy/pull/24754">Pull Request 24754</a>. Note that lambdifying
expressions is also faster with <tt class="docutils literal">cse=True</tt>. Here is the timing in SymPy
1.11.1:</p>
<div class="highlight"><pre><span></span>In [1]: %time f_without_cse = lambdify((x, p), large_expr)
CPU times: user 29.4 s, sys: 91.3 ms, total: 29.5 s
Wall time: 29.5 s

In [2]: %time f_with_cse = lambdify((x, p), large_expr, cse=True)
CPU times: user 14.5 s, sys: 15.8 ms, total: 14.5 s
Wall time: 14.5 s
</pre></div>
<p>and then the same in SymPy 1.12:</p>
<div class="highlight"><pre><span></span>In [1]: %time f_without_cse = lambdify((x, p), large_expr)
CPU times: user 17.9 s, sys: 68.4 ms, total: 18 s
Wall time: 18 s

In [2]: %time f_with_cse = lambdify((x, p), large_expr, cse=True)
CPU times: user 2.77 s, sys: 7.93 ms, total: 2.77 s
Wall time: 2.77 s
</pre></div>
<p>Using <tt class="docutils literal">cse=True</tt> with <tt class="docutils literal">lambdify()</tt>, results in significantly faster
numerical evaluation:</p>
<div class="highlight"><pre><span></span>In [2]: %timeit f_without_cse(x_vals, p_vals)
40.7 ms ± 824 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [3]: %timeit f_with_cse(x_vals, p_vals)
264 µs ± 7.37 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)
</pre></div>
<p>For this example, the CSE version is <strong>154X faster</strong> at execution.</p>
</div>
<div class="section" id="modeling-and-optimal-control-uses">
<h2><a class="toc-backref" href="#toc-entry-13">Modeling and Optimal Control Uses</a></h2>
<p>As explained in the introduction, our goal is to make SymPy capable of deriving
computationally efficient neuromuscular driven multibody models. One use case
for these models is solving <a class="reference external" href="https://en.wikipedia.org/wiki/Optimal_control">optimal control</a> problems, which benefit greatly
from exact derivatives and the fastest numerical evaluation of the equations of
motion and its higher-order partial derivatives. In particular, forming a
<a class="reference external" href="https://en.wikipedia.org/wiki/Nonlinear_programming">nonlinear programming</a> problem using direct collocation transcription from
very large symbolic equations of motion was already known to push SymPy's past
its limits.  In the past, we have developed two software packages that
transcribe and solve optimal control problems based on SymPy expressions: <a class="reference external" href="https://github.com/csu-hmc/opty">opty</a>
and <a class="reference external" href="https://github.com/brocksam/pycollo">pycollo</a>. We use both programs below to solve two challenging optimal
control problems and detail the improvements we made to the packages.</p>
<div class="section" id="optimal-skateboard-ollie">
<h3><a class="toc-backref" href="#toc-entry-14">Optimal Skateboard Ollie</a></h3>
<p>As a first demonstration that SymPy can be used to solve research-grade optimal
control problems, TU Delft MSc student Jan Heinen developed a model of a
skateboarder performing an ollie, the fundamental jumping trick in the sport.
Jan used SymPy to formulate the equations of motion of this biomechanical
human-machine system and used pycollo to solve the multi-phase trajectory
optimization and parameter identification optimal control problem. Jan
succeeded and produced an MSc thesis and a preprint that is currently under
review at the journal Sports Engineering:</p>
<ul class="simple">
<li>TU Delft MSc thesis: <a class="reference external" href="http://resolver.tudelft.nl/uuid:61f4e969-8bd1-4687-9942-b70024b216dc">Optimal Skateboard Geometry for Maximizing Ollie Height</a></li>
<li>engrXiv preprint: <a class="reference external" href="https://doi.org/10.31224/3171">Maximizing Ollie Height by Optimizing Control Strategy and
Skateboard Geometry Using Direct Collocation</a></li>
</ul>
<p>This video shows the simulations of the problem solutions:</p>
<center>
<iframe width="560" height="315"
src="https://www.youtube.com/embed/jw5DmNnvD7c" title="YouTube video player"
frameborder="0" allow="accelerometer; autoplay; clipboard-write;
encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</center><p>Following his MSc project, Jan contributed Sphinx documentation and examples to
the pycollo project with the following pull requests:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/80">https://github.com/brocksam/pycollo/pull/80</a></li>
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/82">https://github.com/brocksam/pycollo/pull/82</a></li>
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/84">https://github.com/brocksam/pycollo/pull/84</a></li>
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/85">https://github.com/brocksam/pycollo/pull/85</a></li>
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/87">https://github.com/brocksam/pycollo/pull/87</a></li>
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/88">https://github.com/brocksam/pycollo/pull/88</a></li>
</ul>
</div>
<div class="section" id="brim">
<h3><a class="toc-backref" href="#toc-entry-15">BRiM</a></h3>
<p>All of our prior bicycle-rider human-machine system models were one-off
derivations that were repurposed for each new model variation. These had
varying accessibility for other users. Timo came up with the idea to develop a
software package that allows you to build bicycle-rider models from modular
elements, yet still retain a minimal coordinate derivation of the equations of
motion. His MSc thesis, &quot;<a class="reference external" href="http://resolver.tudelft.nl/uuid:a2b132e9-8d38-4553-8587-0c9e3341b202">BRiM: A Modular Bicycle-Rider Modeling Framework</a>&quot;,
details the design, implementation, and use of BRiM. We also wrote a paper,
&quot;<a class="reference external" href="https://doi.org/10.59490/6504c5a765e8118fc7b106c3">BRiM: A Modular Bicycle-Rider Modeling Framework</a>&quot;, for the Bicycle and
Motorcycle Dynamics 2023 conference that gives a more concise overview of the
package as well as demonstrating easily swapping models for comparable optimal
control results.</p>
<div class="figure align-center">
<img alt="" src="https://objects-us-east-1.dream.io/mechmotum/brim-lane-change.gif" style="width: 80%;" />
<p class="caption">Figure 3: Lane change simulation created with BRiM showing without and
without a rider.</p>
</div>
<ul class="simple">
<li>BRiM source code: <a class="reference external" href="https://github.com/TJStienstra/brim/">https://github.com/TJStienstra/brim/</a></li>
<li>BRiM documentation: <a class="reference external" href="https://tjstienstra.github.io/brim/">https://tjstienstra.github.io/brim/</a></li>
<li>BRiM BMD 2023 paper: <a class="reference external" href="https://doi.org/10.59490/6504c5a765e8118fc7b106c3">https://doi.org/10.59490/6504c5a765e8118fc7b106c3</a></li>
<li>BRiM BMD 2023 paper source code: <a class="reference external" href="https://github.com/TJStienstra/brim-bmd-2023-paper">https://github.com/TJStienstra/brim-bmd-2023-paper</a></li>
</ul>
</div>
<div class="section" id="optimal-bicycle-rider-trajectories">
<h3><a class="toc-backref" href="#toc-entry-16">Optimal Bicycle-Rider Trajectories</a></h3>
<p>With all of the above work, we were able to solve an optimal control problem of
the muscle-driven bicycle and rider. This is the problem we posed:</p>
<blockquote>
Given a multibody model of the Carvallo-Whipple bicycle model extended with
a rider that has muscle actuated movable arms and given a desired path on
the ground, can we find muscle activations that cause the bicycle-rider to
follow the path as closely as possible while minimizing the effort from the
representative biceps and triceps?</blockquote>
<p>The objective of this optimal control problem takes the form:</p>
<div class="math">
\begin{equation*}
J = (1 - w)\int_{t_0}^{t_f} \left[x_s(t) - x_d(t)\right]^2 dt +
w\int_{t_0}^{t_f} e(t)^2 dt
\end{equation*}
</div>
<p>where <span class="math">\(x_s\)</span> are a subset of the model's state trajectories and
<span class="math">\(x_d\)</span> are some desired trajectories and <span class="math">\(e\)</span> are the muscle
excitation inputs. <span class="math">\(w\)</span> is a weighting factor for the two terms. This is a
typical minimal effort tracking formulation.</p>
<p>The equations of motion of this system have about 2.8 million mathematical
operations. Forming the constraints that represent these equations of motion (a
set of differential algebraic equations in this case) involves computing a very
large sparse Jacobian with 440 thousand non-zero entries. When we first
attempted the differentiation for the Jacobian of the discretized bicycle-rider
model, SymPy bogged down on the Jacobian calculation. We let the computation
run for <strong>over 3 hours</strong> and killed the execution before the computation
completed. SymPy's differentiation is unusable for interactive work with large
equations of motion such as these. Since we already find the common
sub-expressions of the equations of motion before code generation in opty, Sam
implemented a very efficient forward Jacobian on the expression directed
acyclic graph (DAG) in pull request: <a class="reference external" href="https://github.com/csu-hmc/opty/pull/102">https://github.com/csu-hmc/opty/pull/102</a>.</p>
<p>This allowed the equations to be differentiated and the differentiation occurs
in less than 45 seconds (at least a <strong>250X</strong> speed increase), showing the
drastic improvements such an approach can have. Once this fix was applied we
were finally able to solve the tracking trajectory optimization problem with
<a class="reference external" href="https://github.com/csu-hmc/opty">opty</a>.</p>
<p>This problem has these characteristics:</p>
<ul class="simple">
<li>Number of operations in the equations of motion: 2,775,718</li>
<li>Number of constraints: 6394</li>
<li>Number of free variables: 7400</li>
<li>Number of non-zero entries in the Jacobian of the constraints: 439,438</li>
</ul>
<p>and solves with these timings:</p>
<ul class="simple">
<li>Time to differentiate the constraints: 43 seconds</li>
<li>Total time to code generate, form the Jacobian, and compile the C code: 185
seconds</li>
<li>Average time to evaluate the constraints: 201 µs</li>
<li>Average time to evaluate the Jacobian: 1.29 ms</li>
<li>Number of IPOPT iterations: 267</li>
<li>Time in IPOPT: 45 seconds</li>
</ul>
<table border="1" class="borderless docutils align-center" style="width: 100%">
<caption>Figure 4: Optimal control simualtion results for a 2 meter
lange change at a nomimal 1 m/s riding speed. The top left shows the desired
(blue) and actual (orange) ground path. The top right graph shows the
generalized coordintes. <span class="math">\(q_7\)</span> is the steer angle in degrees, for example. The
bottom left shows the generalized speeds. <span class="math">\(u_1\)</span> is the forward speed.
The bottom right graphs shows the muscle excitation inputs for pedaling
torque <span class="math">\(T_6\)</span> and the biceps and triceps.</caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr><td><img alt="muscle-bike-rider-01" src="https://objects-us-east-1.dream.io/mechmotum/muscle-bike-rider-01.png" style="width: 100%;" /></td>
<td><img alt="muscle-bike-rider-02" src="https://objects-us-east-1.dream.io/mechmotum/muscle-bike-rider-02.png" style="width: 100%;" /></td>
</tr>
<tr><td><img alt="muscle-bike-rider-03" src="https://objects-us-east-1.dream.io/mechmotum/muscle-bike-rider-03.png" style="width: 100%;" /></td>
<td><img alt="muscle-bike-rider-04" src="https://objects-us-east-1.dream.io/mechmotum/muscle-bike-rider-04.png" style="width: 100%;" /></td>
</tr>
</tbody>
</table>
<p>The simulation codes and the draft paper about the results can be found in the
following repository:</p>
<p><a class="reference external" href="https://github.com/brocksam/muscle-driven-bicycle-paper">https://github.com/brocksam/muscle-driven-bicycle-paper</a></p>
<p>The need to evaluate both a function and its Jacobian is a common use case that
is not just limited to optimal control problems like the one shown above. SymPy
is capable of taking analytical derivatives but it can be prohibitory slow for
large expressions. This limits interactive use and rapid iteration in equation
derivation. If common sub-expressions are extracted from a SymPy expression,
all operations are represented as a directed acyclic graph.  Taking the
derivative of a DAG instead of a tree graph, as SymPy stores expressions, can
provide exponential speedups to differentiation. If the code generation for the
function and its Jacobian uses common sub-expression elimination, then it makes
sense to call <tt class="docutils literal">cse()</tt> on the function, then take the partial derivatives, and
the Jacobian will be in a DAG form for easy code generation. Sam has
introduced a major code generation speed up for lambdifying large SymPy
expressions if you also desire the Jacobian based on the work we did in opty.
The details are  in the following pull requests:</p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/sympy/sympy/pull/24649">https://github.com/sympy/sympy/pull/24649</a></li>
<li><a class="reference external" href="https://github.com/sympy/sympy/pull/25797">https://github.com/sympy/sympy/pull/25797</a></li>
<li><a class="reference external" href="https://github.com/sympy/sympy/pull/25801">https://github.com/sympy/sympy/pull/25801</a></li>
</ul>
</div>
</div>
<div class="section" id="conclusion">
<h2><a class="toc-backref" href="#toc-entry-17">Conclusion</a></h2>
<p>We completed almost all of the goals set out in the original proposal along
with many more unplanned achievements. SymPy is now more suited for solving
non-trivial biomechanical optimal control problems and improvements to the
performance of lambdify() will help a broad set of use cases. Our experience
also led to many new ideas on how to further improve SymPy for large expression
manipulation, especially how unevaluated expression forms that use DAGs as the
core data structure can drastically speed up SymPy and reduce the computational
resources needed.</p>
<div class="section" id="lessons-learned">
<h3><a class="toc-backref" href="#toc-entry-18">Lessons Learned</a></h3>
<p>New contributors to large open source projects should start with pull requests
that are small and uncontroversial to build up momentum. Sam started with a
pull request to switch SymPy's 15 year old testing framework to pytest. This
consumed a lot of time and stalled regularly which in return stalled his other
pull requests because he built out the tests with advanced pytest features.</p>
<p>We had planned for 0.5 FTE over the two year period, but it took about 6 months
to negotiate a subcontract between TU Delft and Quantsight, since it was the
first one of its kind. After that, it took another six months before we
interivewed candidates, hired one, and Sam could start. There was not enough
time in the grant period for the contract and hiring process. It still worked
out, but this is something to plan for in the future.</p>
<p>We developed a large plan for the additions to SymPy that was tough to separate
into independent smaller pieces. This led Sam and Timo to work on a set of
large interconnected Git branches that would be merged when finished. This
ended up leaving us with very large pull requests to review and made it harder
for other SymPy developers to interact on the draft work. We also merged all of
the new material as private modules (leading underscores in their file names)
so that we could make breaking changes in case a SymPy release occurred before
we finished the whole plan. The development branch approach was not ideal,
SymPy usually has only one development branch, so we should probably avoid that
in the future. Merging private modules is a fine approach and is done in other
places in SymPy, but you have to have a plan to make them public.</p>
<p>Our proposal had three work packages. After hiring Sam, we realized his prior
experience and ideas for SymPy improvement had overlap with Oscar's plans. By
the time we understood what exactly we would do, we failed to have more
collaborative work between the two related work packages. In the future, it
would be good to have more early brainstorm meetings to initiate close
collaboration.</p>
</div>
<div class="section" id="future-plans">
<h3><a class="toc-backref" href="#toc-entry-19">Future Plans</a></h3>
<p>We plan to finish any of the unmerged pull requests for the SymPy 1.13 release
and the paper on the optimal control of the bicycle-rider system is ongoing
work. In the future, we are very interested in incorporating unevaluated
expressions and the DAG data structures more into the core of SymPy, as these
two ideas can vastly enhance SymPy's performance and the ability to code
generate from SymPy expressions with more control and precision. We hope that
other users will try out and contribute to the new biomechanics package as well
as use SymPy + opty &amp; pycollo for solving optimal control problems of
biomechanical multibody systems.</p>
</div>
</div>
<div class="section" id="work-summary">
<h2><a class="toc-backref" href="#toc-entry-20">Work Summary</a></h2>
<p>The following list summarizes the various products we have delivered as part of
the CZI funding (code, papers, documentation):</p>
<ul class="simple">
<li>Pull requests to SymPy:<ul>
<li><a class="reference external" href="https://github.com/sympy/sympy/pulls?q=is%3Apr+label%3A%22CZI%3A+Codegen%2FBiomech%22">https://github.com/sympy/sympy/pulls?q=is%3Apr+label%3A%22CZI%3A+Codegen%2FBiomech%22</a></li>
<li><a class="reference external" href="https://github.com/sympy/sympy_benchmarks/pulls?q=is%3Apr+author%3Abrocksam">https://github.com/sympy/sympy_benchmarks/pulls?q=is%3Apr+author%3Abrocksam</a></li>
</ul>
</li>
<li>Pull request to opty: <a class="reference external" href="https://github.com/csu-hmc/opty/pull/102">https://github.com/csu-hmc/opty/pull/102</a></li>
<li>Pull requests to pycollo:<ul>
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/80">https://github.com/brocksam/pycollo/pull/80</a></li>
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/82">https://github.com/brocksam/pycollo/pull/82</a></li>
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/84">https://github.com/brocksam/pycollo/pull/84</a></li>
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/85">https://github.com/brocksam/pycollo/pull/85</a></li>
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/87">https://github.com/brocksam/pycollo/pull/87</a></li>
<li><a class="reference external" href="https://github.com/brocksam/pycollo/pull/88">https://github.com/brocksam/pycollo/pull/88</a></li>
</ul>
</li>
<li>Ollie Optimization paper and code:<ul>
<li><a class="reference external" href="https://github.com/mechmotum/ollie-optimization">https://github.com/mechmotum/ollie-optimization</a></li>
</ul>
</li>
<li>BRiM software package:<ul>
<li>Source code: <a class="reference external" href="https://github.com/TJStienstra/brim/">https://github.com/TJStienstra/brim/</a></li>
<li>Documentation: <a class="reference external" href="https://tjstienstra.github.io/brim/">https://tjstienstra.github.io/brim/</a></li>
<li>BMD 2023 paper: <a class="reference external" href="https://doi.org/10.59490/6504c5a765e8118fc7b106c3">https://doi.org/10.59490/6504c5a765e8118fc7b106c3</a></li>
<li>BMD 2023 paper source code: <a class="reference external" href="https://github.com/TJStienstra/brim-bmd-2023-paper">https://github.com/TJStienstra/brim-bmd-2023-paper</a></li>
</ul>
</li>
<li>Bicycle steering optimal control paper:<ul>
<li><a class="reference external" href="https://github.com/brocksam/muscle-driven-bicycle-paper">https://github.com/brocksam/muscle-driven-bicycle-paper</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="references">
<h2><a class="toc-backref" href="#toc-entry-21">References</a></h2>
<table class="docutils citation" frame="void" id="meijaard2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#citation-reference-2">[Meijaard2007]</a></td><td>J. P. Meijaard, J. M. Papadopoulos, A. Ruina, and A. L.
Schwab, “Linearized dynamics equations for the balance and steer of a
bicycle: A benchmark and review,” Proceedings of the Royal Society A:
Mathematical, Physical and Engineering Sciences, vol. 463, no. 2084, pp.
1955–1982, Aug. 2007.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="basumandal2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#citation-reference-1">[BasuMandal2007]</a></td><td>P. Basu-Mandal, A. Chatterjee, and J. M. Papadopoulos,
&quot;Hands-free circular motions of a benchmark bicycle,&quot; Proceedings of the
Royal Society A: Mathematical, Physical and Engineering Sciences, vol. 463,
no. 2084, pp. 1983–2003, Aug. 2007.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="degroote2016" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#citation-reference-4">[DeGroote2016]</a></td><td>De Groote, F., Kinney, A. L., Rao, A. V., &amp; Fregly, B. J.,
Evaluation of direct collocation optimal control problem formulations for
solving the muscle redundancy problem, Annals of biomedical engineering,
44(10), (2016) pp. 2922-2936</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="bird2011" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#citation-reference-3">[Bird2011]</a></td><td>Richard S. Bird, A simple division-free algorithm for computing
determinants, Information Processing Letters, Volume 111, Issues 21–22,
2011, Pages 1072-1074, ISSN 0020-0190,
<a class="reference external" href="https://doi.org/10.1016/j.ipl.2011.08.006">https://doi.org/10.1016/j.ipl.2011.08.006</a>.</td></tr>
</tbody>
</table>
</div>
<script type='text/javascript'>if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </div>
  </article>
  <hr>
  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function() {
      this.page.url = 'https://mechmotum.github.io/blog/czi-sympy-wrapup.html';
      this.page.identifier = 'sympy-czi-outcomes';
    };
    (function() {
      var d = document;
      var s = d.createElement('script');
      s.src = '//mechmotum.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript class="text-muted">
    Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
  </noscript>
    </div>
  </div>

  <footer class="footer">
    <div class="container">
<div class="row">
  <ul class="col-sm-6 list-inline">
      <li class="list-inline-item"><a href="https://mechmotum.github.io/authors.html">Authors</a></li>
    <li class="list-inline-item"><a href="https://mechmotum.github.io/archives.html">Archives</a></li>
    <li class="list-inline-item"><a href="https://mechmotum.github.io/categories.html">Categories</a></li>
      <li class="list-inline-item"><a href="https://mechmotum.github.io/tags.html">Tags</a></li>
  </ul>
  <p class="col-sm-6 text-sm-right text-muted">
    Generated by <a href="https://github.com/getpelican/pelican" target="_blank">Pelican</a>
    / <a href="https://github.com/nairobilug/pelican-alchemy"
         target="_blank">&#x2728;</a>
    | Edit on <a href="https://github.com/mechmotum/mechmotum.github.io" target="_blank"><i class="fab fa-github"></i></a>
  </p>
</div>
<div class="row">
  <div class="col-sm-4 mx-auto text-center text-muted" >
    <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
      <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" />
    </a>
    <br />
    This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
  </div>
</div>    </div>
  </footer>

</body>

</html>